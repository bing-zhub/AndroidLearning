'use strict';

const cryptoUtils = require('./cryptoUtils');
const RestQuery = require('./RestQuery');
const Parse = require('parse/node');

// An Auth object tells you who is requesting something and whether
// the master key was used.
// userObject is a Parse.User and can be null if there's no user.
function Auth({ config, isMaster = false, isReadOnly = false, user, installationId } = {}) {
  this.config = config;
  this.installationId = installationId;
  this.isMaster = isMaster;
  this.user = user;
  this.isReadOnly = isReadOnly;

  // Assuming a users roles won't change during a single request, we'll
  // only load them once.
  this.userRoles = [];
  this.fetchedRoles = false;
  this.rolePromise = null;
}

// Whether this auth could possibly modify the given user id.
// It still could be forbidden via ACLs even if this returns true.
Auth.prototype.isUnauthenticated = function () {
  if (this.isMaster) {
    return false;
  }
  if (this.user) {
    return false;
  }
  return true;
};

// A helper to get a master-level Auth object
function master(config) {
  return new Auth({ config, isMaster: true });
}

// A helper to get a master-level Auth object
function readOnly(config) {
  return new Auth({ config, isMaster: true, isReadOnly: true });
}

// A helper to get a nobody-level Auth object
function nobody(config) {
  return new Auth({ config, isMaster: false });
}

// Returns a promise that resolves to an Auth object
var getAuthForSessionToken = function ({ config, sessionToken, installationId } = {}) {
  return config.cacheController.user.get(sessionToken).then(userJSON => {
    if (userJSON) {
      const cachedUser = Parse.Object.fromJSON(userJSON);
      return Promise.resolve(new Auth({ config, isMaster: false, installationId, user: cachedUser }));
    }

    var restOptions = {
      limit: 1,
      include: 'user'
    };

    var query = new RestQuery(config, master(config), '_Session', { sessionToken }, restOptions);
    return query.execute().then(response => {
      var results = response.results;
      if (results.length !== 1 || !results[0]['user']) {
        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
      }

      var now = new Date(),
          expiresAt = results[0].expiresAt ? new Date(results[0].expiresAt.iso) : undefined;
      if (expiresAt < now) {
        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token is expired.');
      }
      var obj = results[0]['user'];
      delete obj.password;
      obj['className'] = '_User';
      obj['sessionToken'] = sessionToken;
      config.cacheController.user.put(sessionToken, obj);
      const userObject = Parse.Object.fromJSON(obj);
      return new Auth({ config, isMaster: false, installationId, user: userObject });
    });
  });
};

var getAuthForLegacySessionToken = function ({ config, sessionToken, installationId } = {}) {
  var restOptions = {
    limit: 1
  };
  var query = new RestQuery(config, master(config), '_User', { sessionToken: sessionToken }, restOptions);
  return query.execute().then(response => {
    var results = response.results;
    if (results.length !== 1) {
      throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'invalid legacy session token');
    }
    const obj = results[0];
    obj.className = '_User';
    const userObject = Parse.Object.fromJSON(obj);
    return new Auth({ config, isMaster: false, installationId, user: userObject });
  });
};

// Returns a promise that resolves to an array of role names
Auth.prototype.getUserRoles = function () {
  if (this.isMaster || !this.user) {
    return Promise.resolve([]);
  }
  if (this.fetchedRoles) {
    return Promise.resolve(this.userRoles);
  }
  if (this.rolePromise) {
    return this.rolePromise;
  }
  this.rolePromise = this._loadRoles();
  return this.rolePromise;
};

// Iterates through the role tree and compiles a users roles
Auth.prototype._loadRoles = function () {
  var cacheAdapter = this.config.cacheController;
  return cacheAdapter.role.get(this.user.id).then(cachedRoles => {
    if (cachedRoles != null) {
      this.fetchedRoles = true;
      this.userRoles = cachedRoles;
      return Promise.resolve(cachedRoles);
    }

    var restWhere = {
      'users': {
        __type: 'Pointer',
        className: '_User',
        objectId: this.user.id
      }
    };
    // First get the role ids this user is directly a member of
    var query = new RestQuery(this.config, master(this.config), '_Role', restWhere, {});
    return query.execute().then(response => {
      var results = response.results;
      if (!results.length) {
        this.userRoles = [];
        this.fetchedRoles = true;
        this.rolePromise = null;

        cacheAdapter.role.put(this.user.id, Array(...this.userRoles));
        return Promise.resolve(this.userRoles);
      }
      var rolesMap = results.reduce((m, r) => {
        m.names.push(r.name);
        m.ids.push(r.objectId);
        return m;
      }, { ids: [], names: [] });

      // run the recursive finding
      return this._getAllRolesNamesForRoleIds(rolesMap.ids, rolesMap.names).then(roleNames => {
        this.userRoles = roleNames.map(r => {
          return 'role:' + r;
        });
        this.fetchedRoles = true;
        this.rolePromise = null;
        cacheAdapter.role.put(this.user.id, Array(...this.userRoles));
        return Promise.resolve(this.userRoles);
      });
    });
  });
};

// Given a list of roleIds, find all the parent roles, returns a promise with all names
Auth.prototype._getAllRolesNamesForRoleIds = function (roleIDs, names = [], queriedRoles = {}) {
  const ins = roleIDs.filter(roleID => {
    return queriedRoles[roleID] !== true;
  }).map(roleID => {
    // mark as queried
    queriedRoles[roleID] = true;
    return {
      __type: 'Pointer',
      className: '_Role',
      objectId: roleID
    };
  });

  // all roles are accounted for, return the names
  if (ins.length == 0) {
    return Promise.resolve([...new Set(names)]);
  }
  // Build an OR query across all parentRoles
  let restWhere;
  if (ins.length == 1) {
    restWhere = { 'roles': ins[0] };
  } else {
    restWhere = { 'roles': { '$in': ins } };
  }
  const query = new RestQuery(this.config, master(this.config), '_Role', restWhere, {});
  return query.execute().then(response => {
    var results = response.results;
    // Nothing found
    if (!results.length) {
      return Promise.resolve(names);
    }
    // Map the results with all Ids and names
    const resultMap = results.reduce((memo, role) => {
      memo.names.push(role.name);
      memo.ids.push(role.objectId);
      return memo;
    }, { ids: [], names: [] });
    // store the new found names
    names = names.concat(resultMap.names);
    // find the next ones, circular roles will be cut
    return this._getAllRolesNamesForRoleIds(resultMap.ids, names, queriedRoles);
  }).then(names => {
    return Promise.resolve([...new Set(names)]);
  });
};

const createSession = function (config, {
  userId,
  createdWith,
  installationId,
  additionalSessionData
}) {
  const token = 'r:' + cryptoUtils.newToken();
  const expiresAt = config.generateSessionExpiresAt();
  const sessionData = {
    sessionToken: token,
    user: {
      __type: 'Pointer',
      className: '_User',
      objectId: userId
    },
    createdWith,
    restricted: false,
    expiresAt: Parse._encode(expiresAt)
  };

  if (installationId) {
    sessionData.installationId = installationId;
  }

  Object.assign(sessionData, additionalSessionData);
  // We need to import RestWrite at this point for the cyclic dependency it has to it
  const RestWrite = require('./RestWrite');

  return {
    sessionData,
    createSession: () => new RestWrite(config, master(config), '_Session', null, sessionData).execute()
  };
};

module.exports = {
  Auth,
  master,
  nobody,
  readOnly,
  getAuthForSessionToken,
  getAuthForLegacySessionToken,
  createSession
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9BdXRoLmpzIl0sIm5hbWVzIjpbImNyeXB0b1V0aWxzIiwicmVxdWlyZSIsIlJlc3RRdWVyeSIsIlBhcnNlIiwiQXV0aCIsImNvbmZpZyIsImlzTWFzdGVyIiwiaXNSZWFkT25seSIsInVzZXIiLCJpbnN0YWxsYXRpb25JZCIsInVzZXJSb2xlcyIsImZldGNoZWRSb2xlcyIsInJvbGVQcm9taXNlIiwicHJvdG90eXBlIiwiaXNVbmF1dGhlbnRpY2F0ZWQiLCJtYXN0ZXIiLCJyZWFkT25seSIsIm5vYm9keSIsImdldEF1dGhGb3JTZXNzaW9uVG9rZW4iLCJzZXNzaW9uVG9rZW4iLCJjYWNoZUNvbnRyb2xsZXIiLCJnZXQiLCJ0aGVuIiwidXNlckpTT04iLCJjYWNoZWRVc2VyIiwiT2JqZWN0IiwiZnJvbUpTT04iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3RPcHRpb25zIiwibGltaXQiLCJpbmNsdWRlIiwicXVlcnkiLCJleGVjdXRlIiwicmVzcG9uc2UiLCJyZXN1bHRzIiwibGVuZ3RoIiwiRXJyb3IiLCJJTlZBTElEX1NFU1NJT05fVE9LRU4iLCJub3ciLCJEYXRlIiwiZXhwaXJlc0F0IiwiaXNvIiwidW5kZWZpbmVkIiwib2JqIiwicGFzc3dvcmQiLCJwdXQiLCJ1c2VyT2JqZWN0IiwiZ2V0QXV0aEZvckxlZ2FjeVNlc3Npb25Ub2tlbiIsImNsYXNzTmFtZSIsImdldFVzZXJSb2xlcyIsIl9sb2FkUm9sZXMiLCJjYWNoZUFkYXB0ZXIiLCJyb2xlIiwiaWQiLCJjYWNoZWRSb2xlcyIsInJlc3RXaGVyZSIsIl9fdHlwZSIsIm9iamVjdElkIiwiQXJyYXkiLCJyb2xlc01hcCIsInJlZHVjZSIsIm0iLCJyIiwibmFtZXMiLCJwdXNoIiwibmFtZSIsImlkcyIsIl9nZXRBbGxSb2xlc05hbWVzRm9yUm9sZUlkcyIsInJvbGVOYW1lcyIsIm1hcCIsInJvbGVJRHMiLCJxdWVyaWVkUm9sZXMiLCJpbnMiLCJmaWx0ZXIiLCJyb2xlSUQiLCJTZXQiLCJyZXN1bHRNYXAiLCJtZW1vIiwiY29uY2F0IiwiY3JlYXRlU2Vzc2lvbiIsInVzZXJJZCIsImNyZWF0ZWRXaXRoIiwiYWRkaXRpb25hbFNlc3Npb25EYXRhIiwidG9rZW4iLCJuZXdUb2tlbiIsImdlbmVyYXRlU2Vzc2lvbkV4cGlyZXNBdCIsInNlc3Npb25EYXRhIiwicmVzdHJpY3RlZCIsIl9lbmNvZGUiLCJhc3NpZ24iLCJSZXN0V3JpdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLE1BQU1BLGNBQWNDLFFBQVEsZUFBUixDQUFwQjtBQUNBLE1BQU1DLFlBQVlELFFBQVEsYUFBUixDQUFsQjtBQUNBLE1BQU1FLFFBQVFGLFFBQVEsWUFBUixDQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVNHLElBQVQsQ0FBYyxFQUFFQyxNQUFGLEVBQVVDLFdBQVcsS0FBckIsRUFBNEJDLGFBQWEsS0FBekMsRUFBZ0RDLElBQWhELEVBQXNEQyxjQUF0RCxLQUF5RSxFQUF2RixFQUEyRjtBQUN6RixPQUFLSixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLSSxjQUFMLEdBQXNCQSxjQUF0QjtBQUNBLE9BQUtILFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsT0FBS0UsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsT0FBS0QsVUFBTCxHQUFrQkEsVUFBbEI7O0FBRUE7QUFDQTtBQUNBLE9BQUtHLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxPQUFLQyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0EsT0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNEOztBQUVEO0FBQ0E7QUFDQVIsS0FBS1MsU0FBTCxDQUFlQyxpQkFBZixHQUFtQyxZQUFXO0FBQzVDLE1BQUksS0FBS1IsUUFBVCxFQUFtQjtBQUNqQixXQUFPLEtBQVA7QUFDRDtBQUNELE1BQUksS0FBS0UsSUFBVCxFQUFlO0FBQ2IsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVJEOztBQVVBO0FBQ0EsU0FBU08sTUFBVCxDQUFnQlYsTUFBaEIs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RGdCLFNBQU9pRSxNQUFQLENBQWNILFdBQWQsRUFBMkJKLHFCQUEzQjtBQUNBO0FBQ0EsUUFBTVEsWUFBWTFGLFFBQVEsYUFBUixDQUFsQjs7QUFFQSxTQUFPO0FBQ0xzRixlQURLO0FBRUxQLG1CQUFlLE1BQU0sSUFBSVcsU0FBSixDQUFjdEYsTUFBZCxFQUFzQlUsT0FBT1YsTUFBUCxDQUF0QixFQUFzQyxVQUF0QyxFQUFrRCxJQUFsRCxFQUF3RGtGLFdBQXhELEVBQXFFdEQsT0FBckU7QUFGaEIsR0FBUDtBQUlELENBaENEOztBQWtDQTJELE9BQU9DLE9BQVAsR0FBaUI7QUFDZnpGLE1BRGU7QUFFZlcsUUFGZTtBQUdmRSxRQUhlO0FBSWZELFVBSmU7QUFLZkUsd0JBTGU7QUFNZjhCLDhCQU5lO0FBT2ZnQztBQVBlLENBQWpCIiwiZmlsZSI6IkF1dGguanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcnlwdG9VdGlscyA9IHJlcXVpcmUoJy4vY3J5cHRvVXRpbHMnKTtcbmNvbnN0IFJlc3RRdWVyeSA9IHJlcXVpcmUoJy4vUmVzdFF1ZXJ5Jyk7XG5jb25zdCBQYXJzZSA9IHJlcXVpcmUoJ3BhcnNlL25vZGUnKTtcblxuLy8gQW4gQXV0aCBvYmplY3QgdGVsbHMgeW91IHdobyBpcyByZXF1ZXN0aW5nIHNvbWV0aGluZyBhbmQgd2hldGhlclxuLy8gdGhlIG1hc3RlciBrZXkgd2FzIHVzZWQuXG4vLyB1c2VyT2JqZWN0IGlzIGEgUGFyc2UuVXNlciBhbmQgY2FuIGJlIG51bGwgaWYgdGhlcmUncyBubyB1c2VyLlxuZnVuY3Rpb24gQXV0aCh7IGNvbmZpZywgaXNNYXN0ZXIgPSBmYWxzZSwgaXNSZWFkT25seSA9IGZhbHNlLCB1c2VyLCBpbnN0YWxsYXRpb25JZCB9ID0ge30pIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIHRoaXMuaW5zdGFsbGF0aW9uSWQgPSBpbnN0YWxsYXRpb25JZDtcbiAgdGhpcy5pc01hc3RlciA9IGlzTWFzdGVyO1xuICB0aGlzLnVzZXIgPSB1c2VyO1xuICB0aGlzLmlzUmVhZE9ubHkgPSBpc1JlYWRPbmx5O1xuXG4gIC8vIEFzc3VtaW5nIGEgdXNlcnMgcm9sZXMgd29uJ3QgY2hhbmdlIGR1cmluZyBhIHNpbmdsZSByZXF1ZXN0LCB3ZSdsbFxuICAvLyBvbmx5IGxvYWQgdGhlbSBvbmNlLlxuICB0aGlzLnVzZXJSb2xlcyA9IFtdO1xuICB0aGlzLmZldGNoZWRSb2xlcyA9IGZhbHNlO1xuICB0aGlzLnJvbGVQcm9taXNlID0gbnVsbDtcbn1cblxuLy8gV2hldGhlciB0aGlzIGF1dGggY291bGQgcG9zc2libHkgbW9kaWZ5IHRoZSBnaXZlbiB1c2VyIGlkLlxuLy8gSXQgc3RpbGwgY291bGQgYmUgZm9yYmlkZGVuIHZpYSBBQ0xzIGV2ZW4gaWYgdGhpcyByZXR1cm5zIHRydWUuXG5BdXRoLnByb3RvdHlwZS5pc1VuYXV0aGVudGljYXRlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc01hc3Rlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy51c2VyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQSBoZWxwZXIgdG8gZ2V0IGEgbWFzdGVyLWxldmVsIEF1dGggb2JqZWN0XG5mdW5jdGlvbiBtYXN0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgQXV0aCh7IGNvbmZpZywgaXNNYXN0ZXI6IHRydWUgfSk7XG59XG5cbi8vIEEgaGVscGVyIHRvIGdldCBhIG1hc3Rlci1sZXZlbCBBdXRoIG9iamVjdFxuZnVuY3Rpb24gcmVhZE9ubHkoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgQXV0aCh7IGNvbmZpZywgaXNNYXN0ZXI6IHRydWUsIGlzUmVhZE9ubHk6IHRydWUgfSk7XG59XG5cbi8vIEEgaGVscGVyIHRvIGdldCBhIG5vYm9keS1sZXZlbCBBdXRoIG9iamVjdFxuZnVuY3Rpb24gbm9ib2R5KGNvbmZpZykge1xuICByZXR1cm4gbmV3IEF1dGgoeyBjb25maWcsIGlzTWFzdGVyOiBmYWxzZSB9KTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEF1dGggb2JqZWN0XG52YXIgZ2V0QXV0aEZvclNlc3Npb25Ub2tlbiA9IGZ1bmN0aW9uKHsgY29uZmlnLCBzZXNzaW9uVG9rZW4sIGluc3RhbGxhdGlvbklkIH0gPSB7fSkge1xuICByZXR1cm4gY29uZmlnLmNhY2hlQ29udHJvbGxlci51c2VyLmdldChzZXNzaW9uVG9rZW4pLnRoZW4oKHVzZXJKU09OKSA9PiB7XG4gICAgaWYgKHVzZXJKU09OKSB7XG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0gUGFyc2UuT2JqZWN0LmZyb21KU09OKHVzZXJKU09OKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dGgoe2NvbmZpZywgaXNNYXN0ZXI6IGZhbHNlLCBpbnN0YWxsYXRpb25JZCwgdXNlcjogY2FjaGVkVXNlcn0pKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdE9wdGlvbnMgPSB7XG4gICAgICBsaW1pdDogMSxcbiAgICAgIGluY2x1ZGU6ICd1c2VyJ1xuICAgIH07XG5cbiAgICB2YXIgcXVlcnkgPSBuZXcgUmVzdFF1ZXJ5KGNvbmZpZywgbWFzdGVyKGNvbmZpZyksICdfU2Vzc2lvbicsIHtzZXNzaW9uVG9rZW59LCByZXN0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgdmFyIHJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzO1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoICE9PSAxIHx8ICFyZXN1bHRzWzBdWyd1c2VyJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLklOVkFMSURfU0VTU0lPTl9UT0tFTiwgJ0ludmFsaWQgc2Vzc2lvbiB0b2tlbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKSxcbiAgICAgICAgZXhwaXJlc0F0ID0gcmVzdWx0c1swXS5leHBpcmVzQXQgPyBuZXcgRGF0ZShyZXN1bHRzWzBdLmV4cGlyZXNBdC5pc28pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8IG5vdykge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLFxuICAgICAgICAgICdTZXNzaW9uIHRva2VuIGlzIGV4cGlyZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gcmVzdWx0c1swXVsndXNlciddO1xuICAgICAgZGVsZXRlIG9iai5wYXNzd29yZDtcbiAgICAgIG9ialsnY2xhc3NOYW1lJ10gPSAnX1VzZXInO1xuICAgICAgb2JqWydzZXNzaW9uVG9rZW4nXSA9IHNlc3Npb25Ub2tlbjtcbiAgICAgIGNvbmZpZy5jYWNoZUNvbnRyb2xsZXIudXNlci5wdXQoc2Vzc2lvblRva2VuLCBvYmopO1xuICAgICAgY29uc3QgdXNlck9iamVjdCA9IFBhcnNlLk9iamVjdC5mcm9tSlNPTihvYmopO1xuICAgICAgcmV0dXJuIG5ldyBBdXRoKHtjb25maWcsIGlzTWFzdGVyOiBmYWxzZSwgaW5zdGFsbGF0aW9uSWQsIHVzZXI6IHVzZXJPYmplY3R9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG52YXIgZ2V0QXV0aEZvckxlZ2FjeVNlc3Npb25Ub2tlbiA9IGZ1bmN0aW9uKHtjb25maWcsIHNlc3Npb25Ub2tlbiwgaW5zdGFsbGF0aW9uSWQgfSA9IHt9KSB7XG4gIHZhciByZXN0T3B0aW9ucyA9IHtcbiAgICBsaW1pdDogMVxuICB9O1xuICB2YXIgcXVlcnkgPSBuZXcgUmVzdFF1ZXJ5KGNvbmZpZywgbWFzdGVyKGNvbmZpZyksICdfVXNlcicsIHsgc2Vzc2lvblRva2VuOiBzZXNzaW9uVG9rZW59LCByZXN0T3B0aW9ucyk7XG4gIHJldHVybiBxdWVyeS5leGVjdXRlKCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICB2YXIgcmVzdWx0cyA9IHJlc3BvbnNlLnJlc3VsdHM7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLCAnaW52YWxpZCBsZWdhY3kgc2Vzc2lvbiB0b2tlbicpO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSByZXN1bHRzWzBdO1xuICAgIG9iai5jbGFzc05hbWUgPSAnX1VzZXInO1xuICAgIGNvbnN0IHVzZXJPYmplY3QgPSBQYXJzZS5PYmplY3QuZnJvbUpTT04ob2JqKTtcbiAgICByZXR1cm4gbmV3IEF1dGgoe2NvbmZpZywgaXNNYXN0ZXI6IGZhbHNlLCBpbnN0YWxsYXRpb25JZCwgdXNlcjogdXNlck9iamVjdH0pO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiByb2xlIG5hbWVzXG5BdXRoLnByb3RvdHlwZS5nZXRVc2VyUm9sZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNNYXN0ZXIgfHwgIXRoaXMudXNlcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIGlmICh0aGlzLmZldGNoZWRSb2xlcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy51c2VyUm9sZXMpO1xuICB9XG4gIGlmICh0aGlzLnJvbGVQcm9taXNlKSB7XG4gICAgcmV0dXJuIHRoaXMucm9sZVByb21pc2U7XG4gIH1cbiAgdGhpcy5yb2xlUHJvbWlzZSA9IHRoaXMuX2xvYWRSb2xlcygpO1xuICByZXR1cm4gdGhpcy5yb2xlUHJvbWlzZTtcbn07XG5cbi8vIEl0ZXJhdGVzIHRocm91Z2ggdGhlIHJvbGUgdHJlZSBhbmQgY29tcGlsZXMgYSB1c2VycyByb2xlc1xuQXV0aC5wcm90b3R5cGUuX2xvYWRSb2xlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FjaGVBZGFwdGVyID0gdGhpcy5jb25maWcuY2FjaGVDb250cm9sbGVyO1xuICByZXR1cm4gY2FjaGVBZGFwdGVyLnJvbGUuZ2V0KHRoaXMudXNlci5pZCkudGhlbigoY2FjaGVkUm9sZXMpID0+IHtcbiAgICBpZiAoY2FjaGVkUm9sZXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5mZXRjaGVkUm9sZXMgPSB0cnVlO1xuICAgICAgdGhpcy51c2VyUm9sZXMgPSBjYWNoZWRSb2xlcztcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkUm9sZXMpO1xuICAgIH1cblxuICAgIHZhciByZXN0V2hlcmUgPSB7XG4gICAgICAndXNlcnMnOiB7XG4gICAgICAgIF9fdHlwZTogJ1BvaW50ZXInLFxuICAgICAgICBjbGFzc05hbWU6ICdfVXNlcicsXG4gICAgICAgIG9iamVjdElkOiB0aGlzLnVzZXIuaWRcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIEZpcnN0IGdldCB0aGUgcm9sZSBpZHMgdGhpcyB1c2VyIGlzIGRpcmVjdGx5IGEgbWVtYmVyIG9mXG4gICAgdmFyIHF1ZXJ5ID0gbmV3IFJlc3RRdWVyeSh0aGlzLmNvbmZpZywgbWFzdGVyKHRoaXMuY29uZmlnKSwgJ19Sb2xlJywgcmVzdFdoZXJlLCB7fSk7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgdmFyIHJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzO1xuICAgICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnVzZXJSb2xlcyA9IFtdO1xuICAgICAgICB0aGlzLmZldGNoZWRSb2xlcyA9IHRydWU7XG4gICAgICAgIHRoaXMucm9sZVByb21pc2UgPSBudWxsO1xuXG4gICAgICAgIGNhY2hlQWRhcHRlci5yb2xlLnB1dCh0aGlzLnVzZXIuaWQsIEFycmF5KC4uLnRoaXMudXNlclJvbGVzKSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy51c2VyUm9sZXMpO1xuICAgICAgfVxuICAgICAgdmFyIHJvbGVzTWFwID0gcmVzdWx0cy5yZWR1Y2UoKG0sIHIpID0+IHtcbiAgICAgICAgbS5uYW1lcy5wdXNoKHIubmFtZSk7XG4gICAgICAgIG0uaWRzLnB1c2goci5vYmplY3RJZCk7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfSwge2lkczogW10sIG5hbWVzOiBbXX0pO1xuXG4gICAgICAvLyBydW4gdGhlIHJlY3Vyc2l2ZSBmaW5kaW5nXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0QWxsUm9sZXNOYW1lc0ZvclJvbGVJZHMocm9sZXNNYXAuaWRzLCByb2xlc01hcC5uYW1lcylcbiAgICAgICAgLnRoZW4oKHJvbGVOYW1lcykgPT4ge1xuICAgICAgICAgIHRoaXMudXNlclJvbGVzID0gcm9sZU5hbWVzLm1hcCgocikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICdyb2xlOicgKyByO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZmV0Y2hlZFJvbGVzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJvbGVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICBjYWNoZUFkYXB0ZXIucm9sZS5wdXQodGhpcy51c2VyLmlkLCBBcnJheSguLi50aGlzLnVzZXJSb2xlcykpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy51c2VyUm9sZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBHaXZlbiBhIGxpc3Qgb2Ygcm9sZUlkcywgZmluZCBhbGwgdGhlIHBhcmVudCByb2xlcywgcmV0dXJucyBhIHByb21pc2Ugd2l0aCBhbGwgbmFtZXNcbkF1dGgucHJvdG90eXBlLl9nZXRBbGxSb2xlc05hbWVzRm9yUm9sZUlkcyA9IGZ1bmN0aW9uKHJvbGVJRHMsIG5hbWVzID0gW10sIHF1ZXJpZWRSb2xlcyA9IHt9KSB7XG4gIGNvbnN0IGlucyA9IHJvbGVJRHMuZmlsdGVyKChyb2xlSUQpID0+IHtcbiAgICByZXR1cm4gcXVlcmllZFJvbGVzW3JvbGVJRF0gIT09IHRydWU7XG4gIH0pLm1hcCgocm9sZUlEKSA9PiB7XG4gICAgLy8gbWFyayBhcyBxdWVyaWVkXG4gICAgcXVlcmllZFJvbGVzW3JvbGVJRF0gPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgIGNsYXNzTmFtZTogJ19Sb2xlJyxcbiAgICAgIG9iamVjdElkOiByb2xlSURcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFsbCByb2xlcyBhcmUgYWNjb3VudGVkIGZvciwgcmV0dXJuIHRoZSBuYW1lc1xuICBpZiAoaW5zLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbLi4ubmV3IFNldChuYW1lcyldKTtcbiAgfVxuICAvLyBCdWlsZCBhbiBPUiBxdWVyeSBhY3Jvc3MgYWxsIHBhcmVudFJvbGVzXG4gIGxldCByZXN0V2hlcmU7XG4gIGlmIChpbnMubGVuZ3RoID09IDEpIHtcbiAgICByZXN0V2hlcmUgPSB7ICdyb2xlcyc6IGluc1swXSB9O1xuICB9IGVsc2Uge1xuICAgIHJlc3RXaGVyZSA9IHsgJ3JvbGVzJzogeyAnJGluJzogaW5zIH19XG4gIH1cbiAgY29uc3QgcXVlcnkgPSBuZXcgUmVzdFF1ZXJ5KHRoaXMuY29uZmlnLCBtYXN0ZXIodGhpcy5jb25maWcpLCAnX1JvbGUnLCByZXN0V2hlcmUsIHt9KTtcbiAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIHZhciByZXN1bHRzID0gcmVzcG9uc2UucmVzdWx0cztcbiAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuYW1lcyk7XG4gICAgfVxuICAgIC8vIE1hcCB0aGUgcmVzdWx0cyB3aXRoIGFsbCBJZHMgYW5kIG5hbWVzXG4gICAgY29uc3QgcmVzdWx0TWFwID0gcmVzdWx0cy5yZWR1Y2UoKG1lbW8sIHJvbGUpID0+IHtcbiAgICAgIG1lbW8ubmFtZXMucHVzaChyb2xlLm5hbWUpO1xuICAgICAgbWVtby5pZHMucHVzaChyb2xlLm9iamVjdElkKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHtpZHM6IFtdLCBuYW1lczogW119KTtcbiAgICAvLyBzdG9yZSB0aGUgbmV3IGZvdW5kIG5hbWVzXG4gICAgbmFtZXMgPSBuYW1lcy5jb25jYXQocmVzdWx0TWFwLm5hbWVzKTtcbiAgICAvLyBmaW5kIHRoZSBuZXh0IG9uZXMsIGNpcmN1bGFyIHJvbGVzIHdpbGwgYmUgY3V0XG4gICAgcmV0dXJuIHRoaXMuX2dldEFsbFJvbGVzTmFtZXNGb3JSb2xlSWRzKHJlc3VsdE1hcC5pZHMsIG5hbWVzLCBxdWVyaWVkUm9sZXMpXG4gIH0pLnRoZW4oKG5hbWVzKSA9PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbLi4ubmV3IFNldChuYW1lcyldKVxuICB9KVxufVxuXG5jb25zdCBjcmVhdGVTZXNzaW9uID0gZnVuY3Rpb24oY29uZmlnLCB7XG4gIHVzZXJJZCxcbiAgY3JlYXRlZFdpdGgsXG4gIGluc3RhbGxhdGlvbklkLFxuICBhZGRpdGlvbmFsU2Vzc2lvbkRhdGEsXG59KSB7XG4gIGNvbnN0IHRva2VuID0gJ3I6JyArIGNyeXB0b1V0aWxzLm5ld1Rva2VuKCk7XG4gIGNvbnN0IGV4cGlyZXNBdCA9IGNvbmZpZy5nZW5lcmF0ZVNlc3Npb25FeHBpcmVzQXQoKTtcbiAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB7XG4gICAgc2Vzc2lvblRva2VuOiB0b2tlbixcbiAgICB1c2VyOiB7XG4gICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgIGNsYXNzTmFtZTogJ19Vc2VyJyxcbiAgICAgIG9iamVjdElkOiB1c2VySWRcbiAgICB9LFxuICAgIGNyZWF0ZWRXaXRoLFxuICAgIHJlc3RyaWN0ZWQ6IGZhbHNlLFxuICAgIGV4cGlyZXNBdDogUGFyc2UuX2VuY29kZShleHBpcmVzQXQpXG4gIH07XG5cbiAgaWYgKGluc3RhbGxhdGlvbklkKSB7XG4gICAgc2Vzc2lvbkRhdGEuaW5zdGFsbGF0aW9uSWQgPSBpbnN0YWxsYXRpb25JZFxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihzZXNzaW9uRGF0YSwgYWRkaXRpb25hbFNlc3Npb25EYXRhKTtcbiAgLy8gV2UgbmVlZCB0byBpbXBvcnQgUmVzdFdyaXRlIGF0IHRoaXMgcG9pbnQgZm9yIHRoZSBjeWNsaWMgZGVwZW5kZW5jeSBpdCBoYXMgdG8gaXRcbiAgY29uc3QgUmVzdFdyaXRlID0gcmVxdWlyZSgnLi9SZXN0V3JpdGUnKTtcblxuICByZXR1cm4ge1xuICAgIHNlc3Npb25EYXRhLFxuICAgIGNyZWF0ZVNlc3Npb246ICgpID0+IG5ldyBSZXN0V3JpdGUoY29uZmlnLCBtYXN0ZXIoY29uZmlnKSwgJ19TZXNzaW9uJywgbnVsbCwgc2Vzc2lvbkRhdGEpLmV4ZWN1dGUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBdXRoLFxuICBtYXN0ZXIsXG4gIG5vYm9keSxcbiAgcmVhZE9ubHksXG4gIGdldEF1dGhGb3JTZXNzaW9uVG9rZW4sXG4gIGdldEF1dGhGb3JMZWdhY3lTZXNzaW9uVG9rZW4sXG4gIGNyZWF0ZVNlc3Npb24sXG59O1xuIl19