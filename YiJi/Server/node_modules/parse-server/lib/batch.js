'use strict';

const Parse = require('parse/node').Parse;
const url = require('url');
const path = require('path');
// These methods handle batch requests.
const batchPath = '/batch';

// Mounts a batch-handler onto a PromiseRouter.
function mountOnto(router) {
  router.route('POST', batchPath, req => {
    return handleBatch(router, req);
  });
}

function parseURL(URL) {
  if (typeof URL === 'string') {
    return url.parse(URL);
  }
  return undefined;
}

function makeBatchRoutingPathFunction(originalUrl, serverURL, publicServerURL) {
  serverURL = serverURL ? parseURL(serverURL) : undefined;
  publicServerURL = publicServerURL ? parseURL(publicServerURL) : undefined;

  const apiPrefixLength = originalUrl.length - batchPath.length;
  let apiPrefix = originalUrl.slice(0, apiPrefixLength);

  const makeRoutablePath = function (requestPath) {
    // The routablePath is the path minus the api prefix
    if (requestPath.slice(0, apiPrefix.length) != apiPrefix) {
      throw new Parse.Error(Parse.Error.INVALID_JSON, 'cannot route batch path ' + requestPath);
    }
    return path.posix.join('/', requestPath.slice(apiPrefix.length));
  };

  if (serverURL && publicServerURL && serverURL.path != publicServerURL.path) {
    const localPath = serverURL.path;
    const publicPath = publicServerURL.path;
    // Override the api prefix
    apiPrefix = localPath;
    return function (requestPath) {
      // Build the new path by removing the public path
      // and joining with the local path
      const newPath = path.posix.join('/', localPath, '/', requestPath.slice(publicPath.length));
      // Use the method for local routing
      return makeRoutablePath(newPath);
    };
  }

  return makeRoutablePath;
}

// Returns a promise for a {response} object.
// TODO: pass along auth correctly
function handleBatch(router, req) {
  if (!Array.isArray(req.body.requests)) {
    throw new Parse.Error(Parse.Error.INVALID_JSON, 'requests must be an array');
  }

  // The batch paths are all from the root of our domain.
  // That means they include the API prefix, that the API is mounted
  // to. However, our promise router does not route the api prefix. So
  // we need to figure out the API prefix, so that we can strip it
  // from all the subrequests.
  if (!req.originalUrl.endsWith(batchPath)) {
    throw 'internal routing problem - expected url to end with batch';
  }

  const makeRoutablePath = makeBatchRoutingPathFunction(req.originalUrl, req.config.serverURL, req.config.publicServerURL);

  const promises = req.body.requests.map(restRequest => {
    const routablePath = makeRoutablePath(restRequest.path);
    // Construct a request that we can send to a handler
    const request = {
      body: restRequest.body,
      config: req.config,
      auth: req.auth,
      info: req.info
    };

    return router.tryRouteRequest(restRequest.method, routablePath, request).then(response => {
      return { success: response.response };
    }, error => {
      return { error: { code: error.code, error: error.message } };
    });
  });

  return Promise.all(promises).then(results => {
    return { response: results };
  });
}

module.exports = {
  mountOnto,
  makeBatchRoutingPathFunction
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXRjaC5qcyJdLCJuYW1lcyI6WyJQYXJzZSIsInJlcXVpcmUiLCJ1cmwiLCJwYXRoIiwiYmF0Y2hQYXRoIiwibW91bnRPbnRvIiwicm91dGVyIiwicm91dGUiLCJyZXEiLCJoYW5kbGVCYXRjaCIsInBhcnNlVVJMIiwiVVJMIiwicGFyc2UiLCJ1bmRlZmluZWQiLCJtYWtlQmF0Y2hSb3V0aW5nUGF0aEZ1bmN0aW9uIiwib3JpZ2luYWxVcmwiLCJzZXJ2ZXJVUkwiLCJwdWJsaWNTZXJ2ZXJVUkwiLCJhcGlQcmVmaXhMZW5ndGgiLCJsZW5ndGgiLCJhcGlQcmVmaXgiLCJzbGljZSIsIm1ha2VSb3V0YWJsZVBhdGgiLCJyZXF1ZXN0UGF0aCIsIkVycm9yIiwiSU5WQUxJRF9KU09OIiwicG9zaXgiLCJqb2luIiwibG9jYWxQYXRoIiwicHVibGljUGF0aCIsIm5ld1BhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJib2R5IiwicmVxdWVzdHMiLCJlbmRzV2l0aCIsImNvbmZpZyIsInByb21pc2VzIiwibWFwIiwicmVzdFJlcXVlc3QiLCJyb3V0YWJsZVBhdGgiLCJyZXF1ZXN0IiwiYXV0aCIsImluZm8iLCJ0cnlSb3V0ZVJlcXVlc3QiLCJtZXRob2QiLCJ0aGVuIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiZXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsIlByb21pc2UiLCJhbGwiLCJyZXN1bHRzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxRQUFRQyxRQUFRLFlBQVIsRUFBc0JELEtBQXBDO0FBQ0EsTUFBTUUsTUFBTUQsUUFBUSxLQUFSLENBQVo7QUFDQSxNQUFNRSxPQUFPRixRQUFRLE1BQVIsQ0FBYjtBQUNBO0FBQ0EsTUFBTUcsWUFBWSxRQUFsQjs7QUFFQTtBQUNBLFNBQVNDLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCO0FBQ3pCQSxTQUFPQyxLQUFQLENBQWEsTUFBYixFQUFxQkgsU0FBckIsRUFBaUNJLEdBQUQs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RkU7QUFHZE0sWUFBTWxDLElBQUlrQyxJQUhJO0FBSWRDLFlBQU1uQyxJQUFJbUM7QUFKSSxLQUFoQjs7QUFPQSxXQUFPckMsT0FBT3NDLGVBQVAsQ0FBdUJMLFlBQVlNLE1BQW5DLEVBQTJDTCxZQUEzQyxFQUF5REMsT0FBekQsRUFBa0VLLElBQWxFLENBQXdFQyxRQUFELElBQWM7QUFDMUYsYUFBTyxFQUFDQyxTQUFTRCxTQUFTQSxRQUFuQixFQUFQO0FBQ0QsS0FGTSxFQUVIRSxLQUFELElBQVc7QUFDWixhQUFPLEVBQUNBLE9BQU8sRUFBQ0MsTUFBTUQsTUFBTUMsSUFBYixFQUFtQkQsT0FBT0EsTUFBTUUsT0FBaEMsRUFBUixFQUFQO0FBQ0QsS0FKTSxDQUFQO0FBS0QsR0FmZ0IsQ0FBakI7O0FBaUJBLFNBQU9DLFFBQVFDLEdBQVIsQ0FBWWhCLFFBQVosRUFBc0JTLElBQXRCLENBQTRCUSxPQUFELElBQWE7QUFDN0MsV0FBTyxFQUFDUCxVQUFVTyxPQUFYLEVBQVA7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFREMsT0FBT0MsT0FBUCxHQUFpQjtBQUNmbkQsV0FEZTtBQUVmUztBQUZlLENBQWpCIiwiZmlsZSI6ImJhdGNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUGFyc2UgPSByZXF1aXJlKCdwYXJzZS9ub2RlJykuUGFyc2U7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4vLyBUaGVzZSBtZXRob2RzIGhhbmRsZSBiYXRjaCByZXF1ZXN0cy5cbmNvbnN0IGJhdGNoUGF0aCA9ICcvYmF0Y2gnO1xuXG4vLyBNb3VudHMgYSBiYXRjaC1oYW5kbGVyIG9udG8gYSBQcm9taXNlUm91dGVyLlxuZnVuY3Rpb24gbW91bnRPbnRvKHJvdXRlcikge1xuICByb3V0ZXIucm91dGUoJ1BPU1QnLCBiYXRjaFBhdGgsIChyZXEpID0+IHtcbiAgICByZXR1cm4gaGFuZGxlQmF0Y2gocm91dGVyLCByZXEpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkwoVVJMKSB7XG4gIGlmICh0eXBlb2YgVVJMID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmwucGFyc2UoVVJMKVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VCYXRjaFJvdXRpbmdQYXRoRnVuY3Rpb24ob3JpZ2luYWxVcmwsIHNlcnZlclVSTCwgcHVibGljU2VydmVyVVJMKSB7XG4gIHNlcnZlclVSTCA9IHNlcnZlclVSTCA/IHBhcnNlVVJMKHNlcnZlclVSTCkgOiB1bmRlZmluZWQ7XG4gIHB1YmxpY1NlcnZlclVSTCA9IHB1YmxpY1NlcnZlclVSTCA/IHBhcnNlVVJMKHB1YmxpY1NlcnZlclVSTCkgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYXBpUHJlZml4TGVuZ3RoID0gb3JpZ2luYWxVcmwubGVuZ3RoIC0gYmF0Y2hQYXRoLmxlbmd0aDtcbiAgbGV0IGFwaVByZWZpeCA9IG9yaWdpbmFsVXJsLnNsaWNlKDAsIGFwaVByZWZpeExlbmd0aCk7XG5cbiAgY29uc3QgbWFrZVJvdXRhYmxlUGF0aCA9IGZ1bmN0aW9uKHJlcXVlc3RQYXRoKSB7XG4gICAgLy8gVGhlIHJvdXRhYmxlUGF0aCBpcyB0aGUgcGF0aCBtaW51cyB0aGUgYXBpIHByZWZpeFxuICAgIGlmIChyZXF1ZXN0UGF0aC5zbGljZSgwLCBhcGlQcmVmaXgubGVuZ3RoKSAhPSBhcGlQcmVmaXgpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLFxuICAgICAgICAnY2Fubm90IHJvdXRlIGJhdGNoIHBhdGggJyArIHJlcXVlc3RQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucG9zaXguam9pbignLycsIHJlcXVlc3RQYXRoLnNsaWNlKGFwaVByZWZpeC5sZW5ndGgpKTtcbiAgfVxuXG4gIGlmIChzZXJ2ZXJVUkwgJiYgcHVibGljU2VydmVyVVJMXG4gICAgICAgICYmIChzZXJ2ZXJVUkwucGF0aCAhPSBwdWJsaWNTZXJ2ZXJVUkwucGF0aCkpIHtcbiAgICBjb25zdCBsb2NhbFBhdGggPSBzZXJ2ZXJVUkwucGF0aDtcbiAgICBjb25zdCBwdWJsaWNQYXRoID0gcHVibGljU2VydmVyVVJMLnBhdGg7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGFwaSBwcmVmaXhcbiAgICBhcGlQcmVmaXggPSBsb2NhbFBhdGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlcXVlc3RQYXRoKSB7XG4gICAgICAvLyBCdWlsZCB0aGUgbmV3IHBhdGggYnkgcmVtb3ZpbmcgdGhlIHB1YmxpYyBwYXRoXG4gICAgICAvLyBhbmQgam9pbmluZyB3aXRoIHRoZSBsb2NhbCBwYXRoXG4gICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5wb3NpeC5qb2luKCcvJywgbG9jYWxQYXRoLCAnLycgLCByZXF1ZXN0UGF0aC5zbGljZShwdWJsaWNQYXRoLmxlbmd0aCkpO1xuICAgICAgLy8gVXNlIHRoZSBtZXRob2QgZm9yIGxvY2FsIHJvdXRpbmdcbiAgICAgIHJldHVybiBtYWtlUm91dGFibGVQYXRoKG5ld1BhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWtlUm91dGFibGVQYXRoO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSB7cmVzcG9uc2V9IG9iamVjdC5cbi8vIFRPRE86IHBhc3MgYWxvbmcgYXV0aCBjb3JyZWN0bHlcbmZ1bmN0aW9uIGhhbmRsZUJhdGNoKHJvdXRlciwgcmVxKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXEuYm9keS5yZXF1ZXN0cykpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLFxuICAgICAgJ3JlcXVlc3RzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIC8vIFRoZSBiYXRjaCBwYXRocyBhcmUgYWxsIGZyb20gdGhlIHJvb3Qgb2Ygb3VyIGRvbWFpbi5cbiAgLy8gVGhhdCBtZWFucyB0aGV5IGluY2x1ZGUgdGhlIEFQSSBwcmVmaXgsIHRoYXQgdGhlIEFQSSBpcyBtb3VudGVkXG4gIC8vIHRvLiBIb3dldmVyLCBvdXIgcHJvbWlzZSByb3V0ZXIgZG9lcyBub3Qgcm91dGUgdGhlIGFwaSBwcmVmaXguIFNvXG4gIC8vIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUgQVBJIHByZWZpeCwgc28gdGhhdCB3ZSBjYW4gc3RyaXAgaXRcbiAgLy8gZnJvbSBhbGwgdGhlIHN1YnJlcXVlc3RzLlxuICBpZiAoIXJlcS5vcmlnaW5hbFVybC5lbmRzV2l0aChiYXRjaFBhdGgpKSB7XG4gICAgdGhyb3cgJ2ludGVybmFsIHJvdXRpbmcgcHJvYmxlbSAtIGV4cGVjdGVkIHVybCB0byBlbmQgd2l0aCBiYXRjaCc7XG4gIH1cblxuICBjb25zdCBtYWtlUm91dGFibGVQYXRoID0gbWFrZUJhdGNoUm91dGluZ1BhdGhGdW5jdGlvbihyZXEub3JpZ2luYWxVcmwsIHJlcS5jb25maWcuc2VydmVyVVJMLCByZXEuY29uZmlnLnB1YmxpY1NlcnZlclVSTCk7XG5cbiAgY29uc3QgcHJvbWlzZXMgPSByZXEuYm9keS5yZXF1ZXN0cy5tYXAoKHJlc3RSZXF1ZXN0KSA9PiB7XG4gICAgY29uc3Qgcm91dGFibGVQYXRoID0gbWFrZVJvdXRhYmxlUGF0aChyZXN0UmVxdWVzdC5wYXRoKTtcbiAgICAvLyBDb25zdHJ1Y3QgYSByZXF1ZXN0IHRoYXQgd2UgY2FuIHNlbmQgdG8gYSBoYW5kbGVyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGJvZHk6IHJlc3RSZXF1ZXN0LmJvZHksXG4gICAgICBjb25maWc6IHJlcS5jb25maWcsXG4gICAgICBhdXRoOiByZXEuYXV0aCxcbiAgICAgIGluZm86IHJlcS5pbmZvXG4gICAgfTtcblxuICAgIHJldHVybiByb3V0ZXIudHJ5Um91dGVSZXF1ZXN0KHJlc3RSZXF1ZXN0Lm1ldGhvZCwgcm91dGFibGVQYXRoLCByZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgcmV0dXJuIHtzdWNjZXNzOiByZXNwb25zZS5yZXNwb25zZX07XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICByZXR1cm4ge2Vycm9yOiB7Y29kZTogZXJyb3IuY29kZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2V9fTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgcmV0dXJuIHtyZXNwb25zZTogcmVzdWx0c307XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW91bnRPbnRvLFxuICBtYWtlQmF0Y2hSb3V0aW5nUGF0aEZ1bmN0aW9uXG59O1xuIl19