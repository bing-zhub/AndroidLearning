'use strict';

// This file contains helpers for running operations in REST format.
// The goal is that handlers that explicitly handle an express route
// should just be shallow wrappers around things in this file, but
// these functions should not explicitly depend on the request
// object.
// This means that one of these handlers can support multiple
// routes. That's useful for the routes that do really similar
// things.

var Parse = require('parse/node').Parse;

var RestQuery = require('./RestQuery');
var RestWrite = require('./RestWrite');
var triggers = require('./triggers');

function checkTriggers(className, config, types) {
  return types.some(triggerType => {
    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);
  });
}

function checkLiveQuery(className, config) {
  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className);
}

// Returns a promise for an object with optional keys 'results' and 'count'.
function find(config, auth, className, restWhere, restOptions, clientSDK) {
  enforceRoleSecurity('find', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
}

// get is just like find but only queries an objectId.
const get = (config, auth, className, objectId, restOptions, clientSDK) => {
  var restWhere = { objectId };
  enforceRoleSecurity('get', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, true).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
};

// Returns a promise that doesn't resolve to any useful value.
function del(config, auth, className, objectId) {
  if (typeof objectId !== 'string') {
    throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad objectId');
  }

  if (className === '_User' && auth.isUnauthenticated()) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth to delete user');
  }

  enforceRoleSecurity('delete', className, auth);

  var inflatedObject;

  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);
    const hasLiveQuery = checkLiveQuery(className, config);
    if (hasTriggers || hasLiveQuery || className == '_Session') {
      return new RestQuery(config, auth, className, { objectId }).forWrite().execute().then(response => {
        if (response && response.results && response.results.length) {
          const firstResult = response.results[0];
          firstResult.className = className;
          if (className === '_Session' && !auth.isMaster) {
            if (!auth.user || firstResult.user.objectId !== auth.user.id) {
              throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
            }
          }
          var cacheAdapter = config.cacheController;
          cacheAdapter.user.del(firstResult.sessionToken);
          inflatedObject = Parse.Object.fromJSON(firstResult);
          // Notify LiveQuery server if possible
          config.liveQueryController.onAfterDelete(inflatedObject.className, inflatedObject);
          return triggers.maybeRunTrigger(triggers.Types.beforeDelete, auth, inflatedObject, null, config);
        }
        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');
      });
    }
    return Promise.resolve({});
  }).then(() => {
    if (!auth.isMaster) {
      return auth.getUserRoles();
    } else {
      return;
    }
  }).then(() => {
    var options = {};
    if (!auth.isMaster) {
      options.acl = ['*'];
      if (auth.user) {
        options.acl.push(auth.user.id);
        options.acl = options.acl.concat(auth.userRoles);
      }
    }

    return config.database.destroy(className, {
      objectId: objectId
    }, options);
  }).then(() => {
    return triggers.maybeRunTrigger(triggers.Types.afterDelete, auth, inflatedObject, null, config);
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
}

// Returns a promise for a {response, status, location} object.
function create(config, auth, className, restObject, clientSDK) {
  enforceRoleSecurity('create', className, auth);
  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK);
  return write.execute();
}

// Returns a promise that contains the fields of the update that the
// REST API is supposed to return.
// Usually, this is just updatedAt.
function update(config, auth, className, restWhere, restObject, clientSDK) {
  enforceRoleSecurity('update', className, auth);

  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);
    const hasLiveQuery = checkLiveQuery(className, config);
    if (hasTriggers || hasLiveQuery) {
      // Do not use find, as it runs the before finds
      return new RestQuery(config, auth, className, restWhere).forWrite().execute();
    }
    return Promise.resolve({});
  }).then(({ results }) => {
    var originalRestObject;
    if (results && results.length) {
      originalRestObject = results[0];
    }
    return new RestWrite(config, auth, className, restWhere, restObject, originalRestObject, clientSDK).execute();
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
}

function handleSessionMissingError(error, className) {
  // If we're trying to update a user without / with bad session token
  if (className === '_User' && error.code === Parse.Error.OBJECT_NOT_FOUND) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth.');
  }
  throw error;
}

const classesWithMasterOnlyAccess = ['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig', '_JobSchedule'];
// Disallowing access to the _Role collection except by master key
function enforceRoleSecurity(method, className, auth) {
  if (className === '_Installation' && !auth.isMaster) {
    if (method === 'delete' || method === 'find') {
      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;
      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
    }
  }

  //all volatileClasses are masterKey only
  if (classesWithMasterOnlyAccess.indexOf(className) >= 0 && !auth.isMaster) {
    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  }

  // readOnly masterKey is not allowed
  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {
    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  }
}

module.exports = {
  create,
  del,
  find,
  get,
  update
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXN0LmpzIl0sIm5hbWVzIjpbIlBhcnNlIiwicmVxdWlyZSIsIlJlc3RRdWVyeSIsIlJlc3RXcml0ZSIsInRyaWdnZXJzIiwiY2hlY2tUcmlnZ2VycyIsImNsYXNzTmFtZSIsImNvbmZpZyIsInR5cGVzIiwic29tZSIsInRyaWdnZXJUeXBlIiwiZ2V0VHJpZ2dlciIsIlR5cGVzIiwiYXBwbGljYXRpb25JZCIsImNoZWNrTGl2ZVF1ZXJ5IiwibGl2ZVF1ZXJ5Q29udHJvbGxlciIsImhhc0xpdmVRdWVyeSIsImZpbmQiLCJhdXRoIiwicmVzdFdoZXJlIiwicmVzdE9wdGlvbnMiLCJjbGllbnRTREsiLCJlbmZvcmNlUm9sZVNlY3VyaXR5IiwibWF5YmVSdW5RdWVyeVRyaWdnZXIiLCJiZWZvcmVGaW5kIiwidGhlbiIsInJlc3VsdCIsInF1ZXJ5IiwiZXhlY3V0ZSIsImdldCIsIm9iamVjdElkIiwiZGVsIiwiRXJyb3IiLCJJTlZBTElEX0pTT04iLCJpc1VuYXV0aGVudGljYXRlZCIsIlNFU1NJT05fTUlTU0lORyIsImluZmxhdGVkT2JqZWN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJoYXNUcmlnZ2VycyIsImZvcldyaXRlIiwicmVzcG9uc2UiLCJyZXN1bHRzIiwibGVuZ3RoIiwiZmlyc3RSZXN1bHQiLCJpc01hc3RlciIsInVzZXIiLCJpZCIsIklOVkFMSURfU0VTU0lPTl9UT0tFTiIsImNhY2hlQWRhcHRlciIsImNhY2hlQ29udHJvbGxlciIsInNlc3Npb25Ub2tlbiIsIk9iamVjdCIsImZyb21KU09OIiwib25BZnRlckRlbGV0ZSIsIm1heWJlUnVuVHJpZ2dlciIsImJlZm9yZURlbGV0ZSIsIk9CSkVDVF9OT1RfRk9VTkQiLCJnZXRVc2VyUm9sZXMiLCJvcHRpb25zIiwiYWNsIiwicHVzaCIsImNvbmNhdCIsInVzZXJSb2xlcyIsImRhdGFiYXNlIiwiZGVzdHJveSIsImFmdGVyRGVsZXRlIiwiY2F0Y2giLCJlcnJvciIsImhhbmRsZVNlc3Npb25NaXNzaW5nRXJyb3IiLCJjcmVhdGUiLCJyZXN0T2JqZWN0Iiwid3JpdGUiLCJ1cGRhdGUiLCJvcmlnaW5hbFJlc3RPYmplY3QiLCJjb2RlIiwiY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzIiwibWV0aG9kIiwiT1BFUkFUSU9OX0ZPUkJJRERFTiIsImluZGV4T2YiLCJpc1JlYWRPbmx5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlBLFFBQVFDLFFBQVEsWUFBUixFQUFzQkQsS0FBbEM7O0FBRUEsSUFBSUUsWUFBWUQsUUFBUSxhQUFSLENBQWhCO0FBQ0EsSUFBSUUsWUFBWUYsUUFBUSxhQUFSLENBQWhCO0FBQ0EsSUFBSUcsV0FBV0gsUUFBUSxZQUFSLENBQWY7O0FBRUEsU0FBU0ksYUFBVCxDQUF1QkMsU0FBdkIsRUFBa0NDLE1BQWxDLEVBQTBDQyxLQUExQyxFQUFpRDtBQUMvQyxTQUFPQSxNQUFNQyxJQUFOLENBQVlDLFdBQUQsSUFBaUI7QUFDakMsV0FBT04sU0FBU08sVUFBVCxDQUFvQkwsU0FBcEIsRUFBK0JGLFNBQVNRLEtBQVQsQ0FBZUYsV0FBZixDQUEvQixFQUE0REgsT0FBT00sYUFBbkUsQ0FBUDtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVELFNBQVNDLGNBQVQsQ0FBd0JSLFNBQXhCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QyxTQUFPQSxPQUFPUSxtQkFBUCxJQUE4QlIsT0FBT1EsbUJBQVAsQ0FBMkJDLFlBQTNCLENBQXdDVixTQUF4QyxDQUFyQztBQUNEOztBQUVEO0FBQ0EsU0FBU1csSUFBVCxDQUFjVixNQUFkLEVBQXNCVyxJQUF0QixFQUE0QlosU0FBNUIsRUFBdUNhLFNBQXZDLEVBQWtEQyxXQUFsRCxFQUErREMsU0FBL0QsRUFBMEU7QUFDeEVDLHNCQUFvQixNQUFwQixFQUE0QmhCLFNBQTVCLEVBQXVDWSxJQUF2QztBQUNBLFNBQU9kLFNBQVNtQixvQkFB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RFYsS0FBakQsQ0FBTjtBQUNEOztBQUVEO0FBQ0EsTUFBSWxELEtBQUs4RCxVQUFMLEtBQW9CSCxXQUFXLFFBQVgsSUFBdUJBLFdBQVcsUUFBbEMsSUFBOENBLFdBQVcsUUFBN0UsQ0FBSixFQUE0RjtBQUMxRixVQUFNVCxRQUFTLG9EQUFtRFMsTUFBTyxhQUF6RTtBQUNBLFVBQU0sSUFBSTdFLE1BQU1nQyxLQUFWLENBQWdCaEMsTUFBTWdDLEtBQU4sQ0FBWThDLG1CQUE1QixFQUFpRFYsS0FBakQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRURhLE9BQU9DLE9BQVAsR0FBaUI7QUFDZlosUUFEZTtBQUVmdkMsS0FGZTtBQUdmZCxNQUhlO0FBSWZZLEtBSmU7QUFLZjRDO0FBTGUsQ0FBakIiLCJmaWxlIjoicmVzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBjb250YWlucyBoZWxwZXJzIGZvciBydW5uaW5nIG9wZXJhdGlvbnMgaW4gUkVTVCBmb3JtYXQuXG4vLyBUaGUgZ29hbCBpcyB0aGF0IGhhbmRsZXJzIHRoYXQgZXhwbGljaXRseSBoYW5kbGUgYW4gZXhwcmVzcyByb3V0ZVxuLy8gc2hvdWxkIGp1c3QgYmUgc2hhbGxvdyB3cmFwcGVycyBhcm91bmQgdGhpbmdzIGluIHRoaXMgZmlsZSwgYnV0XG4vLyB0aGVzZSBmdW5jdGlvbnMgc2hvdWxkIG5vdCBleHBsaWNpdGx5IGRlcGVuZCBvbiB0aGUgcmVxdWVzdFxuLy8gb2JqZWN0LlxuLy8gVGhpcyBtZWFucyB0aGF0IG9uZSBvZiB0aGVzZSBoYW5kbGVycyBjYW4gc3VwcG9ydCBtdWx0aXBsZVxuLy8gcm91dGVzLiBUaGF0J3MgdXNlZnVsIGZvciB0aGUgcm91dGVzIHRoYXQgZG8gcmVhbGx5IHNpbWlsYXJcbi8vIHRoaW5ncy5cblxudmFyIFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xuXG52YXIgUmVzdFF1ZXJ5ID0gcmVxdWlyZSgnLi9SZXN0UXVlcnknKTtcbnZhciBSZXN0V3JpdGUgPSByZXF1aXJlKCcuL1Jlc3RXcml0ZScpO1xudmFyIHRyaWdnZXJzID0gcmVxdWlyZSgnLi90cmlnZ2VycycpO1xuXG5mdW5jdGlvbiBjaGVja1RyaWdnZXJzKGNsYXNzTmFtZSwgY29uZmlnLCB0eXBlcykge1xuICByZXR1cm4gdHlwZXMuc29tZSgodHJpZ2dlclR5cGUpID0+IHtcbiAgICByZXR1cm4gdHJpZ2dlcnMuZ2V0VHJpZ2dlcihjbGFzc05hbWUsIHRyaWdnZXJzLlR5cGVzW3RyaWdnZXJUeXBlXSwgY29uZmlnLmFwcGxpY2F0aW9uSWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tMaXZlUXVlcnkoY2xhc3NOYW1lLCBjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5saXZlUXVlcnlDb250cm9sbGVyICYmIGNvbmZpZy5saXZlUXVlcnlDb250cm9sbGVyLmhhc0xpdmVRdWVyeShjbGFzc05hbWUpXG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIGZvciBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBrZXlzICdyZXN1bHRzJyBhbmQgJ2NvdW50Jy5cbmZ1bmN0aW9uIGZpbmQoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHJlc3RXaGVyZSwgcmVzdE9wdGlvbnMsIGNsaWVudFNESykge1xuICBlbmZvcmNlUm9sZVNlY3VyaXR5KCdmaW5kJywgY2xhc3NOYW1lLCBhdXRoKTtcbiAgcmV0dXJuIHRyaWdnZXJzLm1heWJlUnVuUXVlcnlUcmlnZ2VyKHRyaWdnZXJzLlR5cGVzLmJlZm9yZUZpbmQsIGNsYXNzTmFtZSwgcmVzdFdoZXJlLCByZXN0T3B0aW9ucywgY29uZmlnLCBhdXRoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICByZXN0V2hlcmUgPSByZXN1bHQucmVzdFdoZXJlIHx8IHJlc3RXaGVyZTtcbiAgICByZXN0T3B0aW9ucyA9IHJlc3VsdC5yZXN0T3B0aW9ucyB8fCByZXN0T3B0aW9ucztcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBSZXN0UXVlcnkoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHJlc3RXaGVyZSwgcmVzdE9wdGlvbnMsIGNsaWVudFNESyk7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUoKTtcbiAgfSk7XG59XG5cbi8vIGdldCBpcyBqdXN0IGxpa2UgZmluZCBidXQgb25seSBxdWVyaWVzIGFuIG9iamVjdElkLlxuY29uc3QgZ2V0ID0gKGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCBvYmplY3RJZCwgcmVzdE9wdGlvbnMsIGNsaWVudFNESykgPT4ge1xuICB2YXIgcmVzdFdoZXJlID0geyBvYmplY3RJZCB9O1xuICBlbmZvcmNlUm9sZVNlY3VyaXR5KCdnZXQnLCBjbGFzc05hbWUsIGF1dGgpO1xuICByZXR1cm4gdHJpZ2dlcnMubWF5YmVSdW5RdWVyeVRyaWdnZXIodHJpZ2dlcnMuVHlwZXMuYmVmb3JlRmluZCwgY2xhc3NOYW1lLCByZXN0V2hlcmUsIHJlc3RPcHRpb25zLCBjb25maWcsIGF1dGgsIHRydWUpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIHJlc3RXaGVyZSA9IHJlc3VsdC5yZXN0V2hlcmUgfHwgcmVzdFdoZXJlO1xuICAgIHJlc3RPcHRpb25zID0gcmVzdWx0LnJlc3RPcHRpb25zIHx8IHJlc3RPcHRpb25zO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFJlc3RRdWVyeShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgcmVzdFdoZXJlLCByZXN0T3B0aW9ucywgY2xpZW50U0RLKTtcbiAgICByZXR1cm4gcXVlcnkuZXhlY3V0ZSgpO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBkb2Vzbid0IHJlc29sdmUgdG8gYW55IHVzZWZ1bCB2YWx1ZS5cbmZ1bmN0aW9uIGRlbChjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgb2JqZWN0SWQpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3RJZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLFxuICAgICAgJ2JhZCBvYmplY3RJZCcpO1xuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSA9PT0gJ19Vc2VyJyAmJiBhdXRoLmlzVW5hdXRoZW50aWNhdGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuU0VTU0lPTl9NSVNTSU5HLFxuICAgICAgJ0luc3VmZmljaWVudCBhdXRoIHRvIGRlbGV0ZSB1c2VyJyk7XG4gIH1cblxuICBlbmZvcmNlUm9sZVNlY3VyaXR5KCdkZWxldGUnLCBjbGFzc05hbWUsIGF1dGgpO1xuXG4gIHZhciBpbmZsYXRlZE9iamVjdDtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgY29uc3QgaGFzVHJpZ2dlcnMgPSBjaGVja1RyaWdnZXJzKGNsYXNzTmFtZSwgY29uZmlnLCBbJ2JlZm9yZURlbGV0ZScsICdhZnRlckRlbGV0ZSddKTtcbiAgICBjb25zdCBoYXNMaXZlUXVlcnkgPSBjaGVja0xpdmVRdWVyeShjbGFzc05hbWUsIGNvbmZpZyk7XG4gICAgaWYgKGhhc1RyaWdnZXJzIHx8IGhhc0xpdmVRdWVyeSB8fCBjbGFzc05hbWUgPT0gJ19TZXNzaW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBSZXN0UXVlcnkoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHsgb2JqZWN0SWQgfSlcbiAgICAgICAgLmZvcldyaXRlKClcbiAgICAgICAgLmV4ZWN1dGUoKVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UucmVzdWx0cyAmJiByZXNwb25zZS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZXN1bHQgPSByZXNwb25zZS5yZXN1bHRzWzBdO1xuICAgICAgICAgICAgZmlyc3RSZXN1bHQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ19TZXNzaW9uJyAmJiAhYXV0aC5pc01hc3Rlcikge1xuICAgICAgICAgICAgICBpZiAoIWF1dGgudXNlciB8fCBmaXJzdFJlc3VsdC51c2VyLm9iamVjdElkICE9PSBhdXRoLnVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLCAnSW52YWxpZCBzZXNzaW9uIHRva2VuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYWNoZUFkYXB0ZXIgPSBjb25maWcuY2FjaGVDb250cm9sbGVyO1xuICAgICAgICAgICAgY2FjaGVBZGFwdGVyLnVzZXIuZGVsKGZpcnN0UmVzdWx0LnNlc3Npb25Ub2tlbik7XG4gICAgICAgICAgICBpbmZsYXRlZE9iamVjdCA9IFBhcnNlLk9iamVjdC5mcm9tSlNPTihmaXJzdFJlc3VsdCk7XG4gICAgICAgICAgICAvLyBOb3RpZnkgTGl2ZVF1ZXJ5IHNlcnZlciBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgY29uZmlnLmxpdmVRdWVyeUNvbnRyb2xsZXIub25BZnRlckRlbGV0ZShpbmZsYXRlZE9iamVjdC5jbGFzc05hbWUsIGluZmxhdGVkT2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cmlnZ2Vycy5tYXliZVJ1blRyaWdnZXIodHJpZ2dlcnMuVHlwZXMuYmVmb3JlRGVsZXRlLCBhdXRoLCBpbmZsYXRlZE9iamVjdCwgbnVsbCwgIGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ09iamVjdCBub3QgZm91bmQgZm9yIGRlbGV0ZS4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICB9KS50aGVuKCgpID0+IHtcbiAgICBpZiAoIWF1dGguaXNNYXN0ZXIpIHtcbiAgICAgIHJldHVybiBhdXRoLmdldFVzZXJSb2xlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KS50aGVuKCgpID0+IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmICghYXV0aC5pc01hc3Rlcikge1xuICAgICAgb3B0aW9ucy5hY2wgPSBbJyonXTtcbiAgICAgIGlmIChhdXRoLnVzZXIpIHtcbiAgICAgICAgb3B0aW9ucy5hY2wucHVzaChhdXRoLnVzZXIuaWQpO1xuICAgICAgICBvcHRpb25zLmFjbCA9IG9wdGlvbnMuYWNsLmNvbmNhdChhdXRoLnVzZXJSb2xlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZy5kYXRhYmFzZS5kZXN0cm95KGNsYXNzTmFtZSwge1xuICAgICAgb2JqZWN0SWQ6IG9iamVjdElkXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0pLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiB0cmlnZ2Vycy5tYXliZVJ1blRyaWdnZXIodHJpZ2dlcnMuVHlwZXMuYWZ0ZXJEZWxldGUsIGF1dGgsIGluZmxhdGVkT2JqZWN0LCBudWxsLCBjb25maWcpO1xuICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBoYW5kbGVTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yLCBjbGFzc05hbWUsIGF1dGgpO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgZm9yIGEge3Jlc3BvbnNlLCBzdGF0dXMsIGxvY2F0aW9ufSBvYmplY3QuXG5mdW5jdGlvbiBjcmVhdGUoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHJlc3RPYmplY3QsIGNsaWVudFNESykge1xuICBlbmZvcmNlUm9sZVNlY3VyaXR5KCdjcmVhdGUnLCBjbGFzc05hbWUsIGF1dGgpO1xuICB2YXIgd3JpdGUgPSBuZXcgUmVzdFdyaXRlKGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCBudWxsLCByZXN0T2JqZWN0LCBudWxsLCBjbGllbnRTREspO1xuICByZXR1cm4gd3JpdGUuZXhlY3V0ZSgpO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBmaWVsZHMgb2YgdGhlIHVwZGF0ZSB0aGF0IHRoZVxuLy8gUkVTVCBBUEkgaXMgc3VwcG9zZWQgdG8gcmV0dXJuLlxuLy8gVXN1YWxseSwgdGhpcyBpcyBqdXN0IHVwZGF0ZWRBdC5cbmZ1bmN0aW9uIHVwZGF0ZShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgcmVzdFdoZXJlLCByZXN0T2JqZWN0LCBjbGllbnRTREspIHtcbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgndXBkYXRlJywgY2xhc3NOYW1lLCBhdXRoKTtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgY29uc3QgaGFzVHJpZ2dlcnMgPSBjaGVja1RyaWdnZXJzKGNsYXNzTmFtZSwgY29uZmlnLCBbJ2JlZm9yZVNhdmUnLCAnYWZ0ZXJTYXZlJ10pO1xuICAgIGNvbnN0IGhhc0xpdmVRdWVyeSA9IGNoZWNrTGl2ZVF1ZXJ5KGNsYXNzTmFtZSwgY29uZmlnKTtcbiAgICBpZiAoaGFzVHJpZ2dlcnMgfHwgaGFzTGl2ZVF1ZXJ5KSB7XG4gICAgICAvLyBEbyBub3QgdXNlIGZpbmQsIGFzIGl0IHJ1bnMgdGhlIGJlZm9yZSBmaW5kc1xuICAgICAgcmV0dXJuIG5ldyBSZXN0UXVlcnkoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHJlc3RXaGVyZSlcbiAgICAgICAgLmZvcldyaXRlKClcbiAgICAgICAgLmV4ZWN1dGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gIH0pLnRoZW4oKHsgcmVzdWx0cyB9KSA9PiB7XG4gICAgdmFyIG9yaWdpbmFsUmVzdE9iamVjdDtcbiAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgb3JpZ2luYWxSZXN0T2JqZWN0ID0gcmVzdWx0c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXN0V3JpdGUoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHJlc3RXaGVyZSwgcmVzdE9iamVjdCwgb3JpZ2luYWxSZXN0T2JqZWN0LCBjbGllbnRTREspXG4gICAgICAuZXhlY3V0ZSgpO1xuICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBoYW5kbGVTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yLCBjbGFzc05hbWUsIGF1dGgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvciwgY2xhc3NOYW1lKSB7XG4gIC8vIElmIHdlJ3JlIHRyeWluZyB0byB1cGRhdGUgYSB1c2VyIHdpdGhvdXQgLyB3aXRoIGJhZCBzZXNzaW9uIHRva2VuXG4gIGlmIChjbGFzc05hbWUgPT09ICdfVXNlcidcbiAgICAgICYmIGVycm9yLmNvZGUgPT09IFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuU0VTU0lPTl9NSVNTSU5HLCAnSW5zdWZmaWNpZW50IGF1dGguJyk7XG4gIH1cbiAgdGhyb3cgZXJyb3I7XG59XG5cbmNvbnN0IGNsYXNzZXNXaXRoTWFzdGVyT25seUFjY2VzcyA9IFsnX0pvYlN0YXR1cycsICdfUHVzaFN0YXR1cycsICdfSG9va3MnLCAnX0dsb2JhbENvbmZpZycsICdfSm9iU2NoZWR1bGUnXTtcbi8vIERpc2FsbG93aW5nIGFjY2VzcyB0byB0aGUgX1JvbGUgY29sbGVjdGlvbiBleGNlcHQgYnkgbWFzdGVyIGtleVxuZnVuY3Rpb24gZW5mb3JjZVJvbGVTZWN1cml0eShtZXRob2QsIGNsYXNzTmFtZSwgYXV0aCkge1xuICBpZiAoY2xhc3NOYW1lID09PSAnX0luc3RhbGxhdGlvbicgJiYgIWF1dGguaXNNYXN0ZXIpIHtcbiAgICBpZiAobWV0aG9kID09PSAnZGVsZXRlJyB8fCBtZXRob2QgPT09ICdmaW5kJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBgQ2xpZW50cyBhcmVuJ3QgYWxsb3dlZCB0byBwZXJmb3JtIHRoZSAke21ldGhvZH0gb3BlcmF0aW9uIG9uIHRoZSBpbnN0YWxsYXRpb24gY29sbGVjdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT1BFUkFUSU9OX0ZPUkJJRERFTiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vYWxsIHZvbGF0aWxlQ2xhc3NlcyBhcmUgbWFzdGVyS2V5IG9ubHlcbiAgaWYoY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwICYmICFhdXRoLmlzTWFzdGVyKXtcbiAgICBjb25zdCBlcnJvciA9IGBDbGllbnRzIGFyZW4ndCBhbGxvd2VkIHRvIHBlcmZvcm0gdGhlICR7bWV0aG9kfSBvcGVyYXRpb24gb24gdGhlICR7Y2xhc3NOYW1lfSBjb2xsZWN0aW9uLmBcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT1BFUkFUSU9OX0ZPUkJJRERFTiwgZXJyb3IpO1xuICB9XG5cbiAgLy8gcmVhZE9ubHkgbWFzdGVyS2V5IGlzIG5vdCBhbGxvd2VkXG4gIGlmIChhdXRoLmlzUmVhZE9ubHkgJiYgKG1ldGhvZCA9PT0gJ2RlbGV0ZScgfHwgbWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnKSkge1xuICAgIGNvbnN0IGVycm9yID0gYHJlYWQtb25seSBtYXN0ZXJLZXkgaXNuJ3QgYWxsb3dlZCB0byBwZXJmb3JtIHRoZSAke21ldGhvZH0gb3BlcmF0aW9uLmBcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT1BFUkFUSU9OX0ZPUkJJRERFTiwgZXJyb3IpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGUsXG4gIGRlbCxcbiAgZmluZCxcbiAgZ2V0LFxuICB1cGRhdGVcbn07XG4iXX0=