'use strict';

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _node = require('parse/node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This auth adapter is based on the OAuth 2.0 Token Introspection specification.
 * See RFC 7662 for details (https://tools.ietf.org/html/rfc7662).
 * It's purpose is to validate OAuth2 access tokens using the OAuth2 provider's
 * token introspection endpoint (if implemented by the provider).
 *
 * The adapter accepts the following config parameters:
 *
 * 1. "endpoint" (string, required)
 *      The URL of the token introspection endpoint of the OAuth2 provider that
 *      issued the access token to the client that is to be validated.
 *
 * 2. "useridField" (string, optional)
 *      The name of the field in the token introspection response that contains
 *      the userid. If specified, it will be used to verify the value of the "id"
 *      field in the "authData" JSON that is coming from the client.
 *      This can be the "aud" (i.e. audience), the "sub" (i.e. subject) or the
 *      "username" field in the introspection response, but since only the
 *      "active" field is required and all other reponse fields are optional
 *      in the RFC, it has to be optional in this adapter as well.
 *      Default: - (undefined)
 *
 * 3. "appidField" (string, optional)
 *      The name of the field in the token introspection response that contains
 *      the appId of the client. If specified, it will be used to verify it's
 *      value against the set of appIds in the adapter config. The concept of
 *      appIds comes from the two major social login providers
 *      (Google and Facebook). They have not yet implemented the token
 *      introspection endpoint, but the concept can be valid for any OAuth2
 *      provider.
 *      Default: - (undefined)
 *
 * 4. "appIds" (array of strings, optional)
 *      A set of appIds that are used to restrict accepted access tokens based
 *      on a specific field's value in the token introspection response.
 *      Default: - (undefined)
 *
 * 5. "authorizationHeader" (string, optional)
 *      The value of the "Authorization" HTTP header in requests sent to the
 *      introspection endpoint.
 *      Eg. "Basic dXNlcm5hbWU6cGFzc3dvcmQ="
 *
 * 6. "debug" (boolean, optional)
 *      Enables extensive logging using the "verbose" level.
 *
 * The adapter expects requests with the following authData JSON:
 *
 * {
 *   "oauth2": {
 *     "id": "user's OAuth2 provider-specific id as a string",
 *     "access_token": "an authorized OAuth2 access token for the user",
 *   }
 * }
 */

class OAuth2AuthAdapter {
  constructor(name) {
    this.name = name;
  }

  // Returns a promise that fulfills if this user id is valid.
  validateAuthData(authData, options) {
    return requestJson(options, authData.access_token).then(response => {
      if (response && response.active && (!options || !options.hasOwnProperty('useridField') || !options.useridField || authData.id == response[options.useridField])) {
        return Promise.resolve();
      }
      return Promise.reject(new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'OAuth2 access token is invalid for this user.'));
    });
  }

  validateAppId(appIds, authData, options) {
    if (options && options.hasOwnProperty('appidField') && options.appidField) {
      if (!appIds.length) {
        return Promise.reject(new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'OAuth2 configuration is missing the client app IDs ("appIds" config parameter).'));
      }
      return requestJson(options, authData.access_token).then(response => {
        const appidField = options.appidField;
        return validateAppIdResponse(response, appidField, appIds);
      });
    } else {
      return Promise.resolve();
    }
  }
}

function getRequestOptions(config, access_token) {
  if (!config || !config.endpoint) {
    throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'OAuth2 token introspection endpoint URL is missing from configuration!');
  }
  const { endpoint } = config;
  const parsedUrl = _url2.default.config(endpoint);
  const postData = _querystring2.default.stringify({
    'token': access_token
  });
  const headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length': Buffer.byteLength(postData)
    // Note: the "authorizationHeader" adapter config must contain the raw value.
    //   Thus if HTTP Basic authorization is to be used, it must contain the
    //   base64 encoded version of the concatenated <username> + ":" + <password> string.
  };if (config.authorizationHeader) {
    headers['Authorization'] = config.authorizationHeader;
  }
  return {
    data: postData,
    options: {
      hostname: parsedUrl.hostname,
      path: parsedUrl.pathname,
      method: 'POST',
      headers: headers
    }
  };
}

function validateAppIdResponse(response, appidField, appIds) {
  if (response && response[appidField]) {
    const responseValue = response[appidField];
    if (Array.isArray(responseValue)) {
      if (responseValue.find((value, index) => {
        return appIds.includes(index);
      })) {
        return Promise.resolve();
      }
    } else {
      if (appIds.includes(responseValue)) {
        return Promise.resolve();
      }
    }
  }
  return Promise.reject(new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'OAuth2: the access_token\'s appID is empty or is not in the list of permitted appIDs in the auth configuration.'));
}

// A promise wrapper for api requests
function requestJson(config, access_token) {
  return new Promise(function (resolve, reject) {
    const { data, options } = getRequestOptions(config, access_token);
    const postRequest = _https2.default.request(options, function (res) {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', function (chunk) {
        data += chunk;
      });
      res.on('end', function () {
        try {
          return resolve(JSON.parse(data));
        } catch (e) {
          return reject(e);
        }
      });
    }).on('error', function () {
      return reject('Failed to validate access token %s with OAuth2 provider (url = %s, headers = %s)', access_token, options.tokenIntrospectionEndpointUrl, JSON.stringify(options.headers));
    });

    postRequest.write(data);
    postRequest.end();
  });
}

module.exports = { OAuth2AuthAdapter, requestJson, getRequestOptions };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL29hdXRoMi5qcyJdLCJuYW1lcyI6WyJPQXV0aDJBdXRoQWRhcHRlciIsImNvbnN0cnVjdG9yIiwibmFtZSIsInZhbGlkYXRlQXV0aERhdGEiLCJhdXRoRGF0YSIsIm9wdGlvbnMiLCJyZXF1ZXN0SnNvbiIsImFjY2Vzc190b2tlbiIsInRoZW4iLCJyZXNwb25zZSIsImFjdGl2ZSIsImhhc093blByb3BlcnR5IiwidXNlcmlkRmllbGQiLCJpZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiUGFyc2UiLCJFcnJvciIsIk9CSkVDVF9OT1RfRk9VTkQiLCJ2YWxpZGF0ZUFwcElkIiwiYXBwSWRzIiwiYXBwaWRGaWVsZCIsImxlbmd0aCIsInZhbGlkYXRlQXBwSWRSZXNwb25zZSIsImdldFJlcXVlc3RPcHRpb25zIiwiY29uZmlnIiwiZW5kcG9pbnQiLCJwYXJzZWRVcmwiLCJ1cmwiLCJwb3N0RGF0YSIsInF1ZXJ5c3RyaW5nIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJhdXRob3JpemF0aW9uSGVhZGVyIiwiZGF0YSIsImhvc3RuYW1lIiwicGF0aCIsInBhdGhuYW1lIiwibWV0aG9kIiwicmVzcG9uc2VWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImZpbmQiLCJ2YWx1ZSIsImluZGV4IiwiaW5jbHVkZXMiLCJwb3N0UmVxdWVzdCIsImh0dHBzIiwicmVxdWVzdCIsInJlcyIsInNldEVuY29kaW5nIiwib24iLCJjaHVuayIsIkpTT04iLCJwYXJzZSIsImUiLCJ0b2tlbkludHJvc3BlY3Rpb25FbmRwb2ludFVybCIsIndyaXRlIiwiZW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUF1REE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQTFEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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T0FBT3FCLENBQVAsRUFBVTtBQUNWLGlCQUFPMUMsT0FBTzBDLENBQVAsQ0FBUDtBQUNEO0FBQ0YsT0FORDtBQU9ELEtBYm1CLEVBYWpCSixFQWJpQixDQWFkLE9BYmMsRUFhTCxZQUFXO0FBQ3hCLGFBQU90QyxPQUFPLGtGQUFQLEVBQTJGVCxZQUEzRixFQUF5R0YsUUFBUXNELDZCQUFqSCxFQUFnSkgsS0FBS3hCLFNBQUwsQ0FBZTNCLFFBQVE0QixPQUF2QixDQUFoSixDQUFQO0FBQ0QsS0FmbUIsQ0FBcEI7O0FBaUJBZ0IsZ0JBQVlXLEtBQVosQ0FBa0J2QixJQUFsQjtBQUNBWSxnQkFBWVksR0FBWjtBQUNELEdBckJNLENBQVA7QUFzQkQ7O0FBRURDLE9BQU9DLE9BQVAsR0FBaUIsRUFBRS9ELGlCQUFGLEVBQXFCTSxXQUFyQixFQUFrQ21CLGlCQUFsQyxFQUFqQiIsImZpbGUiOiJvYXV0aDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogVGhpcyBhdXRoIGFkYXB0ZXIgaXMgYmFzZWQgb24gdGhlIE9BdXRoIDIuMCBUb2tlbiBJbnRyb3NwZWN0aW9uIHNwZWNpZmljYXRpb24uXG4gKiBTZWUgUkZDIDc2NjIgZm9yIGRldGFpbHMgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjYyKS5cbiAqIEl0J3MgcHVycG9zZSBpcyB0byB2YWxpZGF0ZSBPQXV0aDIgYWNjZXNzIHRva2VucyB1c2luZyB0aGUgT0F1dGgyIHByb3ZpZGVyJ3NcbiAqIHRva2VuIGludHJvc3BlY3Rpb24gZW5kcG9pbnQgKGlmIGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlcikuXG4gKlxuICogVGhlIGFkYXB0ZXIgYWNjZXB0cyB0aGUgZm9sbG93aW5nIGNvbmZpZyBwYXJhbWV0ZXJzOlxuICpcbiAqIDEuIFwiZW5kcG9pbnRcIiAoc3RyaW5nLCByZXF1aXJlZClcbiAqICAgICAgVGhlIFVSTCBvZiB0aGUgdG9rZW4gaW50cm9zcGVjdGlvbiBlbmRwb2ludCBvZiB0aGUgT0F1dGgyIHByb3ZpZGVyIHRoYXRcbiAqICAgICAgaXNzdWVkIHRoZSBhY2Nlc3MgdG9rZW4gdG8gdGhlIGNsaWVudCB0aGF0IGlzIHRvIGJlIHZhbGlkYXRlZC5cbiAqXG4gKiAyLiBcInVzZXJpZEZpZWxkXCIgKHN0cmluZywgb3B0aW9uYWwpXG4gKiAgICAgIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCBpbiB0aGUgdG9rZW4gaW50cm9zcGVjdGlvbiByZXNwb25zZSB0aGF0IGNvbnRhaW5zXG4gKiAgICAgIHRoZSB1c2VyaWQuIElmIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIHRvIHZlcmlmeSB0aGUgdmFsdWUgb2YgdGhlIFwiaWRcIlxuICogICAgICBmaWVsZCBpbiB0aGUgXCJhdXRoRGF0YVwiIEpTT04gdGhhdCBpcyBjb21pbmcgZnJvbSB0aGUgY2xpZW50LlxuICogICAgICBUaGlzIGNhbiBiZSB0aGUgXCJhdWRcIiAoaS5lLiBhdWRpZW5jZSksIHRoZSBcInN1YlwiIChpLmUuIHN1YmplY3QpIG9yIHRoZVxuICogICAgICBcInVzZXJuYW1lXCIgZmllbGQgaW4gdGhlIGludHJvc3BlY3Rpb24gcmVzcG9uc2UsIGJ1dCBzaW5jZSBvbmx5IHRoZVxuICogICAgICBcImFjdGl2ZVwiIGZpZWxkIGlzIHJlcXVpcmVkIGFuZCBhbGwgb3RoZXIgcmVwb25zZSBmaWVsZHMgYXJlIG9wdGlvbmFsXG4gKiAgICAgIGluIHRoZSBSRkMsIGl0IGhhcyB0byBiZSBvcHRpb25hbCBpbiB0aGlzIGFkYXB0ZXIgYXMgd2VsbC5cbiAqICAgICAgRGVmYXVsdDogLSAodW5kZWZpbmVkKVxuICpcbiAqIDMuIFwiYXBwaWRGaWVsZFwiIChzdHJpbmcsIG9wdGlvbmFsKVxuICogICAgICBUaGUgbmFtZSBvZiB0aGUgZmllbGQgaW4gdGhlIHRva2VuIGludHJvc3BlY3Rpb24gcmVzcG9uc2UgdGhhdCBjb250YWluc1xuICogICAgICB0aGUgYXBwSWQgb2YgdGhlIGNsaWVudC4gSWYgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gdmVyaWZ5IGl0J3NcbiAqICAgICAgdmFsdWUgYWdhaW5zdCB0aGUgc2V0IG9mIGFwcElkcyBpbiB0aGUgYWRhcHRlciBjb25maWcuIFRoZSBjb25jZXB0IG9mXG4gKiAgICAgIGFwcElkcyBjb21lcyBmcm9tIHRoZSB0d28gbWFqb3Igc29jaWFsIGxvZ2luIHByb3ZpZGVyc1xuICogICAgICAoR29vZ2xlIGFuZCBGYWNlYm9vaykuIFRoZXkgaGF2ZSBub3QgeWV0IGltcGxlbWVudGVkIHRoZSB0b2tlblxuICogICAgICBpbnRyb3NwZWN0aW9uIGVuZHBvaW50LCBidXQgdGhlIGNvbmNlcHQgY2FuIGJlIHZhbGlkIGZvciBhbnkgT0F1dGgyXG4gKiAgICAgIHByb3ZpZGVyLlxuICogICAgICBEZWZhdWx0OiAtICh1bmRlZmluZWQpXG4gKlxuICogNC4gXCJhcHBJZHNcIiAoYXJyYXkgb2Ygc3RyaW5ncywgb3B0aW9uYWwpXG4gKiAgICAgIEEgc2V0IG9mIGFwcElkcyB0aGF0IGFyZSB1c2VkIHRvIHJlc3RyaWN0IGFjY2VwdGVkIGFjY2VzcyB0b2tlbnMgYmFzZWRcbiAqICAgICAgb24gYSBzcGVjaWZpYyBmaWVsZCdzIHZhbHVlIGluIHRoZSB0b2tlbiBpbnRyb3NwZWN0aW9uIHJlc3BvbnNlLlxuICogICAgICBEZWZhdWx0OiAtICh1bmRlZmluZWQpXG4gKlxuICogNS4gXCJhdXRob3JpemF0aW9uSGVhZGVyXCIgKHN0cmluZywgb3B0aW9uYWwpXG4gKiAgICAgIFRoZSB2YWx1ZSBvZiB0aGUgXCJBdXRob3JpemF0aW9uXCIgSFRUUCBoZWFkZXIgaW4gcmVxdWVzdHMgc2VudCB0byB0aGVcbiAqICAgICAgaW50cm9zcGVjdGlvbiBlbmRwb2ludC5cbiAqICAgICAgRWcuIFwiQmFzaWMgZFhObGNtNWhiV1U2Y0dGemMzZHZjbVE9XCJcbiAqXG4gKiA2LiBcImRlYnVnXCIgKGJvb2xlYW4sIG9wdGlvbmFsKVxuICogICAgICBFbmFibGVzIGV4dGVuc2l2ZSBsb2dnaW5nIHVzaW5nIHRoZSBcInZlcmJvc2VcIiBsZXZlbC5cbiAqXG4gKiBUaGUgYWRhcHRlciBleHBlY3RzIHJlcXVlc3RzIHdpdGggdGhlIGZvbGxvd2luZyBhdXRoRGF0YSBKU09OOlxuICpcbiAqIHtcbiAqICAgXCJvYXV0aDJcIjoge1xuICogICAgIFwiaWRcIjogXCJ1c2VyJ3MgT0F1dGgyIHByb3ZpZGVyLXNwZWNpZmljIGlkIGFzIGEgc3RyaW5nXCIsXG4gKiAgICAgXCJhY2Nlc3NfdG9rZW5cIjogXCJhbiBhdXRob3JpemVkIE9BdXRoMiBhY2Nlc3MgdG9rZW4gZm9yIHRoZSB1c2VyXCIsXG4gKiAgIH1cbiAqIH1cbiAqL1xuXG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IFBhcnNlIGZyb20gJ3BhcnNlL25vZGUnO1xuXG5cbmNsYXNzIE9BdXRoMkF1dGhBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIGlmIHRoaXMgdXNlciBpZCBpcyB2YWxpZC5cbiAgdmFsaWRhdGVBdXRoRGF0YShhdXRoRGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiByZXF1ZXN0SnNvbihvcHRpb25zLCBhdXRoRGF0YS5hY2Nlc3NfdG9rZW4pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UgJiZcbiAgICAgICAgcmVzcG9uc2UuYWN0aXZlICYmXG4gICAgICAgICghb3B0aW9ucyB8fCAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndXNlcmlkRmllbGQnKSB8fCAhb3B0aW9ucy51c2VyaWRGaWVsZCB8fCBhdXRoRGF0YS5pZCA9PSByZXNwb25zZVtvcHRpb25zLnVzZXJpZEZpZWxkXSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICAgJ09BdXRoMiBhY2Nlc3MgdG9rZW4gaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLicpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhbGlkYXRlQXBwSWQoYXBwSWRzLCBhdXRoRGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2FwcGlkRmllbGQnKSAmJiBvcHRpb25zLmFwcGlkRmllbGQpIHtcbiAgICAgIGlmICghYXBwSWRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsICdPQXV0aDIgY29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIHRoZSBjbGllbnQgYXBwIElEcyAoXCJhcHBJZHNcIiBjb25maWcgcGFyYW1ldGVyKS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdEpzb24ob3B0aW9ucywgYXV0aERhdGEuYWNjZXNzX3Rva2VuKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBhcHBpZEZpZWxkID0gb3B0aW9ucy5hcHBpZEZpZWxkO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVBcHBJZFJlc3BvbnNlKHJlc3BvbnNlLCBhcHBpZEZpZWxkLCBhcHBJZHMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdE9wdGlvbnMoY29uZmlnLCBhY2Nlc3NfdG9rZW4pIHtcbiAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5lbmRwb2ludCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnT0F1dGgyIHRva2VuIGludHJvc3BlY3Rpb24gZW5kcG9pbnQgVVJMIGlzIG1pc3NpbmcgZnJvbSBjb25maWd1cmF0aW9uIScpO1xuICB9XG4gIGNvbnN0IHsgZW5kcG9pbnQgfSA9IGNvbmZpZztcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLmNvbmZpZyhlbmRwb2ludCk7XG4gIGNvbnN0IHBvc3REYXRhID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHtcbiAgICAndG9rZW4nOiBhY2Nlc3NfdG9rZW5cbiAgfSk7XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKHBvc3REYXRhKVxuICB9XG4gIC8vIE5vdGU6IHRoZSBcImF1dGhvcml6YXRpb25IZWFkZXJcIiBhZGFwdGVyIGNvbmZpZyBtdXN0IGNvbnRhaW4gdGhlIHJhdyB2YWx1ZS5cbiAgLy8gICBUaHVzIGlmIEhUVFAgQmFzaWMgYXV0aG9yaXphdGlvbiBpcyB0byBiZSB1c2VkLCBpdCBtdXN0IGNvbnRhaW4gdGhlXG4gIC8vICAgYmFzZTY0IGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgY29uY2F0ZW5hdGVkIDx1c2VybmFtZT4gKyBcIjpcIiArIDxwYXNzd29yZD4gc3RyaW5nLlxuICBpZiAoY29uZmlnLmF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBjb25maWcuYXV0aG9yaXphdGlvbkhlYWRlcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IHBvc3REYXRhLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGhvc3RuYW1lOiBwYXJzZWRVcmwuaG9zdG5hbWUsXG4gICAgICBwYXRoOiBwYXJzZWRVcmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBcHBJZFJlc3BvbnNlKHJlc3BvbnNlLCBhcHBpZEZpZWxkLCBhcHBJZHMpIHtcbiAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlW2FwcGlkRmllbGRdKSB7XG4gICAgY29uc3QgcmVzcG9uc2VWYWx1ZSA9IHJlc3BvbnNlW2FwcGlkRmllbGRdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlVmFsdWUpKSB7XG4gICAgICBpZiAocmVzcG9uc2VWYWx1ZS5maW5kKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIGFwcElkcy5pbmNsdWRlcyhpbmRleCk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcHBJZHMuaW5jbHVkZXMocmVzcG9uc2VWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFBhcnNlLkVycm9yKFxuICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgJ09BdXRoMjogdGhlIGFjY2Vzc190b2tlblxcJ3MgYXBwSUQgaXMgZW1wdHkgb3IgaXMgbm90IGluIHRoZSBsaXN0IG9mIHBlcm1pdHRlZCBhcHBJRHMgaW4gdGhlIGF1dGggY29uZmlndXJhdGlvbi4nKSk7XG59XG5cbi8vIEEgcHJvbWlzZSB3cmFwcGVyIGZvciBhcGkgcmVxdWVzdHNcbmZ1bmN0aW9uIHJlcXVlc3RKc29uKGNvbmZpZywgYWNjZXNzX3Rva2VuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCB7IGRhdGEsIG9wdGlvbnMgfSA9IGdldFJlcXVlc3RPcHRpb25zKGNvbmZpZywgYWNjZXNzX3Rva2VuKTtcbiAgICBjb25zdCBwb3N0UmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzKSB7XG4gICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICBkYXRhICs9IGNodW5rO1xuICAgICAgfSk7XG4gICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKEpTT04ucGFyc2UoZGF0YSkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5vbignZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWplY3QoJ0ZhaWxlZCB0byB2YWxpZGF0ZSBhY2Nlc3MgdG9rZW4gJXMgd2l0aCBPQXV0aDIgcHJvdmlkZXIgKHVybCA9ICVzLCBoZWFkZXJzID0gJXMpJywgYWNjZXNzX3Rva2VuLCBvcHRpb25zLnRva2VuSW50cm9zcGVjdGlvbkVuZHBvaW50VXJsLCBKU09OLnN0cmluZ2lmeShvcHRpb25zLmhlYWRlcnMpKTtcbiAgICB9KTtcblxuICAgIHBvc3RSZXF1ZXN0LndyaXRlKGRhdGEpO1xuICAgIHBvc3RSZXF1ZXN0LmVuZCgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IE9BdXRoMkF1dGhBZGFwdGVyLCByZXF1ZXN0SnNvbiwgZ2V0UmVxdWVzdE9wdGlvbnMgfTtcbiJdfQ==