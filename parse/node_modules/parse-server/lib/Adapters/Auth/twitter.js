'use strict';

// Helper functions for accessing the twitter API.
var OAuth = require('./OAuth1Client');
var Parse = require('parse/node').Parse;
var logger = require('../../logger').default;

// Returns a promise that fulfills iff this user id is valid.
function validateAuthData(authData, options) {
  if (!options) {
    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Twitter auth configuration missing');
  }
  options = handleMultipleConfigurations(authData, options);
  var client = new OAuth(options);
  client.host = "api.twitter.com";
  client.auth_token = authData.auth_token;
  client.auth_token_secret = authData.auth_token_secret;

  return client.get("/1.1/account/verify_credentials.json").then(data => {
    if (data && data.id_str == '' + authData.id) {
      return;
    }
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
  });
}

// Returns a promise that fulfills iff this app id is valid.
function validateAppId() {
  return Promise.resolve();
}

function handleMultipleConfigurations(authData, options) {
  if (Array.isArray(options)) {
    const consumer_key = authData.consumer_key;
    if (!consumer_key) {
      logger.error('Twitter Auth', 'Multiple twitter configurations are available, by no consumer_key was sent by the client.');
      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
    }
    options = options.filter(option => {
      return option.consumer_key == consumer_key;
    });

    if (options.length == 0) {
      logger.error('Twitter Auth', 'Cannot find a configuration for the provided consumer_key');
      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
    }
    options = options[0];
  }
  return options;
}

module.exports = {
  validateAppId,
  validateAuthData,
  handleMultipleConfigurations
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL3R3aXR0ZXIuanMiXSwibmFtZXMiOlsiT0F1dGgiLCJyZXF1aXJlIiwiUGFyc2UiLCJsb2dnZXIiLCJkZWZhdWx0IiwidmFsaWRhdGVBdXRoRGF0YSIsImF1dGhEYXRhIiwib3B0aW9ucyIsIkVycm9yIiwiSU5URVJOQUxfU0VSVkVSX0VSUk9SIiwiaGFuZGxlTXVsdGlwbGVDb25maWd1cmF0aW9ucyIsImNsaWVudCIsImhvc3QiLCJhdXRoX3Rva2VuIiwiYXV0aF90b2tlbl9zZWNyZXQiLCJnZXQiLCJ0aGVuIiwiZGF0YSIsImlkX3N0ciIsImlkIiwiT0JKRUNUX05PVF9GT1VORCIsInZhbGlkYXRlQXBwSWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkFycmF5IiwiaXNBcnJheSIsImNvbnN1bWVyX2tleSIsImVycm9yIiwiZmlsdGVyIiwib3B0aW9uIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLFFBQVFDLFFBQVEsZ0JBQVIsQ0FBWjtBQUNBLElBQUlDLFFBQVFELFFBQVEsWUFBUixFQUFzQkMsS0FBbEM7QUFDQSxJQUFJQyxTQUFTRixRQUFRLGNBQVIsRUFBd0JHLE9BQXJDOztBQUVBO0FBQ0EsU0FBU0MsZ0JBQVQsQ0FBMEJDLFFBQTFCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxNQUFHLENBQUNBLE9BQUosRUFBYTtBQUNYLFVBQU0sSUFBSUwsTUFBTU0sS0FBVixDQUFnQk4sTUFBTU0sS0FBTixDQUFZQyxxQkFBNUIsRUFBbUQsb0NBQW5ELENBQU47QUFDRDtBQUNERixZQUFVRyw2QkFBNkJKLFFBQTdCLEVBQXVDQyxPQUF2QyxDQUFWO0FBQ0EsTUFBSUksU0FBUyxJQUFJWCxLQUFKLENBQVVPLE9BQVYsQ0FBYjtBQUNBSSxTQUFPQyxJQUFQLEdBQWMsaUJBQWQ7QUFDQUQsU0FBT0UsVUFBUCxHQUFvQlAsU0FBU08sVUFBN0I7QUFDQUYsU0FBT0csaUJBQVAsR0FBMkJSLFNBQVNRLGlCQUFwQzs7QUFFQSxTQUFPSCxPQUFPSSxHQUFQLENBQVcsc0NBQVgsRUFBbURDLElBQW5ELENBQXlEQyxJQUFELElBQVU7QUFDdkUsUUFBSUEsUUFBUUEsS0FBS0MsTUFBTCxJQUFlLEtBQUtaLFNBQVNhLEVBQXpDLEVBQTZDO0FBQzNDO0FBQ0Q7QUFDRCxVQUFNLElBQUlqQixNQUFNTSxLQUFWLENBQ0pOLE1BQU1NLEtBQU4sQ0FBWVksZ0JBRFIsRUFFSix3Q0FGSSxDQUFOO0FBR0QsR0FQTSxDQUFQO0FBUUQ7O0FBRUQ7QUFDQSxTQUFTQyxhQUFULEdBQXlCO0FBQ3ZCLFNBQU9DLFFBQVFDLE9BQVIsRUFBUDtBQUNEOztBQUVELFNBQVNiLDRCQUFULENBQXNDSixRQUF0QyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDdkQsTUFBSWlCLE1BQU1DLE9BQU4sQ0FBY2xCLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixVQUFNbUIsZUFBZXBCLFNBQVNvQixZQUE5QjtBQUNBLFFBQUksQ0FBQ0EsWUFBTCxFQUFtQjtBQUNqQnZCLGFBQU93QixLQUFQLENBQWEsY0FBYixFQUE2QiwyRkFBN0I7QUFDQSxZQUFNLElBQUl6QixNQUFNTSxLQUFWLENBQWdCTixNQUFNTSxLQUFOLENBQVlZLGdCQUE1QixFQUE4Qyx3Q0FBOUMsQ0FBTjtBQUNEO0FBQ0RiLGNBQVVBLFFBQVFxQixNQUFSLENBQWdCQyxNQUFELElBQVk7QUFDbkMsYUFBT0EsT0FBT0gsWUFBUCxJQUF1QkEsWUFBOUI7QUFDRCxLQUZTLENBQVY7O0FBSUEsUUFBSW5CLFFBQVF1QixNQUFSLElBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCM0IsYUFBT3dCLEtBQVAsQ0FBYSxjQUFiLEVBQTRCLDJEQUE1QjtBQUNBLFlBQU0sSUFBSXpCLE1BQU1NLEtBQVYsQ0FBZ0JOLE1BQU1NLEtBQU4sQ0FBWVksZ0JBQTVCLEVBQThDLHdDQUE5QyxDQUFOO0FBQ0Q7QUFDRGIsY0FBVUEsUUFBUSxDQUFSLENBQVY7QUFDRDtBQUNELFNBQU9BLE9BQVA7QUFDRDs7QUFFRHdCLE9BQU9DLE9BQVAsR0FBaUI7QUFDZlgsZUFEZTtBQUVmaEIsa0JBRmU7QUFHZks7QUFIZSxDQUFqQiIsImZpbGUiOiJ0d2l0dGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgYWNjZXNzaW5nIHRoZSB0d2l0dGVyIEFQSS5cbnZhciBPQXV0aCA9IHJlcXVpcmUoJy4vT0F1dGgxQ2xpZW50Jyk7XG52YXIgUGFyc2UgPSByZXF1aXJlKCdwYXJzZS9ub2RlJykuUGFyc2U7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyJykuZGVmYXVsdDtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZmYgdGhpcyB1c2VyIGlkIGlzIHZhbGlkLlxuZnVuY3Rpb24gdmFsaWRhdGVBdXRoRGF0YShhdXRoRGF0YSwgb3B0aW9ucykge1xuICBpZighb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5JTlRFUk5BTF9TRVJWRVJfRVJST1IsICdUd2l0dGVyIGF1dGggY29uZmlndXJhdGlvbiBtaXNzaW5nJyk7XG4gIH1cbiAgb3B0aW9ucyA9IGhhbmRsZU11bHRpcGxlQ29uZmlndXJhdGlvbnMoYXV0aERhdGEsIG9wdGlvbnMpO1xuICB2YXIgY2xpZW50ID0gbmV3IE9BdXRoKG9wdGlvbnMpO1xuICBjbGllbnQuaG9zdCA9IFwiYXBpLnR3aXR0ZXIuY29tXCI7XG4gIGNsaWVudC5hdXRoX3Rva2VuID0gYXV0aERhdGEuYXV0aF90b2tlbjtcbiAgY2xpZW50LmF1dGhfdG9rZW5fc2VjcmV0ID0gYXV0aERhdGEuYXV0aF90b2tlbl9zZWNyZXQ7XG5cbiAgcmV0dXJuIGNsaWVudC5nZXQoXCIvMS4xL2FjY291bnQvdmVyaWZ5X2NyZWRlbnRpYWxzLmpzb25cIikudGhlbigoZGF0YSkgPT4ge1xuICAgIGlmIChkYXRhICYmIGRhdGEuaWRfc3RyID09ICcnICsgYXV0aERhdGEuaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICdUd2l0dGVyIGF1dGggaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLicpO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZmYgdGhpcyBhcHAgaWQgaXMgdmFsaWQuXG5mdW5jdGlvbiB2YWxpZGF0ZUFwcElkKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU11bHRpcGxlQ29uZmlndXJhdGlvbnMoYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBjb25zdCBjb25zdW1lcl9rZXkgPSBhdXRoRGF0YS5jb25zdW1lcl9rZXk7XG4gICAgaWYgKCFjb25zdW1lcl9rZXkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignVHdpdHRlciBBdXRoJywgJ011bHRpcGxlIHR3aXR0ZXIgY29uZmlndXJhdGlvbnMgYXJlIGF2YWlsYWJsZSwgYnkgbm8gY29uc3VtZXJfa2V5IHdhcyBzZW50IGJ5IHRoZSBjbGllbnQuJyk7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCwgJ1R3aXR0ZXIgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zLmZpbHRlcigob3B0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gb3B0aW9uLmNvbnN1bWVyX2tleSA9PSBjb25zdW1lcl9rZXk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdUd2l0dGVyIEF1dGgnLCdDYW5ub3QgZmluZCBhIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwcm92aWRlZCBjb25zdW1lcl9rZXknKTtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnVHdpdHRlciBhdXRoIGlzIGludmFsaWQgZm9yIHRoaXMgdXNlci4nKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNbMF07XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZUFwcElkLFxuICB2YWxpZGF0ZUF1dGhEYXRhLFxuICBoYW5kbGVNdWx0aXBsZUNvbmZpZ3VyYXRpb25zXG59O1xuIl19